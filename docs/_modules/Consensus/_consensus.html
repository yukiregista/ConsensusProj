<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Consensus._consensus &mdash; ConsensusProj https://github.com/yukiregista/ConsensusProj documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=0484f6ff"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            ConsensusProj
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../Consensus.html">Consensus package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">ConsensusProj</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">Consensus._consensus</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for Consensus._consensus</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">dendropy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">bitstring</span> <span class="kn">import</span> <span class="n">Bits</span>
<span class="kn">from</span> <span class="nn">Bio</span> <span class="kn">import</span> <span class="n">Phylo</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">squareform</span>
<span class="kn">from</span> <span class="nn">scipy.cluster.hierarchy</span> <span class="kn">import</span> <span class="n">to_tree</span>
<span class="kn">from</span> <span class="nn">scipy.cluster.hierarchy</span> <span class="kn">import</span> <span class="n">linkage</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span><span class="o">,</span> <span class="nn">string</span>
<span class="kn">import</span> <span class="nn">time</span>


<span class="k">def</span> <span class="nf">_get_newick</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent_dist</span><span class="p">,</span> <span class="n">leaf_names</span><span class="p">,</span> <span class="n">newick</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert sciply.cluster.hierarchy.to_tree()-output to Newick format.</span>
<span class="sd">    </span>
<span class="sd">    Code copied from https://stackoverflow.com/questions/28222179/save-dendrogram-to-newick-format.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node : _type_</span>
<span class="sd">        output of sciply.cluster.hierarchy.to_tree()</span>
<span class="sd">    parent_dist : _type_</span>
<span class="sd">        output of sciply.cluster.hierarchy.to_tree().dist</span>
<span class="sd">    leaf_names : List</span>
<span class="sd">        list of leaf names</span>
<span class="sd">    newick : str, optional</span>
<span class="sd">        leave empty, this variable is used in recursion., by default &#39;&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        tree in Newick format</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">:</span><span class="si">%.2f%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">leaf_names</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">],</span> <span class="n">parent_dist</span> <span class="o">-</span> <span class="n">node</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span> <span class="n">newick</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newick</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">newick</span> <span class="o">=</span> <span class="s2">&quot;):</span><span class="si">%.2f%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">parent_dist</span> <span class="o">-</span> <span class="n">node</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span> <span class="n">newick</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newick</span> <span class="o">=</span> <span class="s2">&quot;);&quot;</span>
        <span class="n">newick</span> <span class="o">=</span> <span class="n">_get_newick</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">get_left</span><span class="p">(),</span> <span class="n">node</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span> <span class="n">leaf_names</span><span class="p">,</span> <span class="n">newick</span><span class="o">=</span><span class="n">newick</span><span class="p">)</span>
        <span class="n">newick</span> <span class="o">=</span> <span class="n">_get_newick</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">get_right</span><span class="p">(),</span> <span class="n">node</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span> <span class="n">leaf_names</span><span class="p">,</span> <span class="n">newick</span><span class="o">=</span><span class="s2">&quot;,</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">newick</span><span class="p">))</span>
        <span class="n">newick</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">newick</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newick</span>

<span class="k">def</span> <span class="nf">TBE</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">,</span> <span class="n">treelist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute TBE of given set of bipartitions against input trees.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bipartitions : Iterable of `dendropy.datamodel.treemodel.Bipartition`</span>
<span class="sd">        Bipartitions to evaluate TBE support.</span>
<span class="sd">    treelist : TreeList_with_support or Iterable of either Tree_with_support or </span>
<span class="sd">        Input trees to evaluate TBE support against.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Trees that produce input bipartitions and treelist need to have the same taxon_namespace.</span>
<span class="sd">    </span>
<span class="sd">    Otherwise, the produced TBE support will not be a valid one.</span>
<span class="sd">    </span>
<span class="sd">    Please check this manually, as we don&#39;t check it inside the function.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Array of TBE support. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">n_taxa</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">treelist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
    <span class="n">refinfo</span> <span class="o">=</span> <span class="n">_create_refinfo</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">,</span> <span class="n">n_taxa</span><span class="p">)</span>
    <span class="n">n_bipartitions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">)</span>
    <span class="n">totalSupport</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bipartitions</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">treelist</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">bipartition_encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
        <span class="n">tree_bipartition_ints</span> <span class="o">=</span> <span class="p">[</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span> <span class="k">for</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">):</span>
            <span class="n">bipar_int</span> <span class="o">=</span> <span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">bipar_int</span> <span class="ow">in</span> <span class="n">tree_bipartition_ints</span><span class="p">:</span>
                <span class="n">support</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">refinfo</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">support</span>  <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">support</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">_minDist</span><span class="p">(</span><span class="n">refinfo</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">],</span> <span class="n">tree</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">refinfo</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">totalSupport</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">support</span>
    
    <span class="n">totalSupport</span> <span class="o">=</span> <span class="n">totalSupport</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">treelist</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">totalSupport</span>

<span class="k">def</span> <span class="nf">unnormalized_TBE</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">,</span> <span class="n">treelist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unnormalized version of transfer bootstrap expectation.</span>
<span class="sd">    </span>
<span class="sd">    Due to the lack of normalization, contrary to the usual TBE, the lower value (close to zero) indicates well supported edges.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bipartitions : Iterable of `dendropy.datamodel.treemodel.Bipartition`</span>
<span class="sd">        Bipartitions to evaluate unnormalized TBE.</span>
<span class="sd">    treelist : TreeList_with_support or Iterable of either Tree_with_support or </span>
<span class="sd">        Input trees to evaluate unnormalized TBE against.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Array of unnormalized TBE. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_taxa</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">treelist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
    <span class="n">refinfo</span> <span class="o">=</span> <span class="n">_create_refinfo</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">,</span> <span class="n">n_taxa</span><span class="p">)</span>
    <span class="n">n_bipartitions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">)</span>
    <span class="n">totalDistance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bipartitions</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">treelist</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">bipartition_encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
        <span class="n">tree_bipartition_ints</span> <span class="o">=</span> <span class="p">[</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span> <span class="k">for</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">):</span>
            <span class="n">bipar_int</span> <span class="o">=</span> <span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">bipar_int</span> <span class="ow">in</span> <span class="n">tree_bipartition_ints</span><span class="p">:</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">refinfo</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">distance</span>  <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">_minDist</span><span class="p">(</span><span class="n">refinfo</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">],</span> <span class="n">tree</span><span class="p">)</span>
            <span class="n">totalDistance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">distance</span>
    
    <span class="n">totalDistance</span> <span class="o">=</span> <span class="n">totalDistance</span><span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">treelist</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">totalDistance</span>


<span class="k">def</span> <span class="nf">_create_refinfo</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">,</span> <span class="n">n_taxa</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function for TBE</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bipartitions : Iterable of `dendropy.datamodel.treemodel.Bipartition`</span>
<span class="sd">        _description_</span>
<span class="sd">    n_taxa : int</span>
<span class="sd">        _description_</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        bipar_int as key an tuple of (bitstr, p) as value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># bipartitions: iterable of dendropy.Bipartition</span>
    <span class="n">refinfo</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="n">bipartitions</span><span class="p">:</span>
        <span class="n">edge_bitstr</span> <span class="o">=</span> <span class="n">Bits</span><span class="p">(</span><span class="n">uint</span> <span class="o">=</span> <span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">(),</span> <span class="n">length</span><span class="o">=</span><span class="n">n_taxa</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge_bitstr</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">edge_bitstr</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># zero lready assigned to light side</span>
            <span class="n">bitstr</span> <span class="o">=</span> <span class="n">edge_bitstr</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># reverse bitstring</span>
            <span class="n">bitstr</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">edge_bitstr</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">refinfo</span><span class="p">[</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bitstr</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="c1"># O( len(bipartitions) *  n_taxa )</span>
    <span class="k">return</span> <span class="n">refinfo</span>

<span class="k">def</span> <span class="nf">_minDist</span><span class="p">(</span><span class="n">refinfo_b</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper minDist function for computing TBE.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    refinfo_b : dict</span>
<span class="sd">        refinfo of bipartition b created by _create_refinfo function.</span>
<span class="sd">    tree : Tree_with_support or dendropy.datamodel.treemodel.Tree</span>
<span class="sd">        Tree to compute support of the bipartition</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function expects input bipartition (``refinfo_b``) to be NOT included in ``tree``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Hamming distance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># bipartition: Bipartition object</span>
    <span class="c1"># tree: Tree_with_support or Tree object</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">refinfo_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">b_bitstr</span> <span class="o">=</span> <span class="n">refinfo_b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="c1">#edge_bitstr = Bits(uint = bipartition.split_as_int(), length=self.n_taxa)</span>
    <span class="c1">#p = min(edge_bitstr.count(1), edge_bitstr.count(0))</span>
    <span class="c1">#m = len(tree.edge)</span>

    <span class="c1"># WE ASSUME THAT bipartition and tree has the exact same TAXON_NAMESPACE </span>
    <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">taxon_namespace</span>
    <span class="n">taxon_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="n">taxon_namespace</span><span class="p">]</span>
    <span class="n">n_taxa</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">taxon_labels</span><span class="p">)</span>
    <span class="n">taxon_labels_to_bitstr_digit</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">taxon_labels</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_taxa</span><span class="p">)]))</span>
    <span class="n">node_biparint_to_postorder_index</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">bipartition_encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
    
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="p">)</span>
    <span class="n">CountOnesSubtree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">CountZerosSubtree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">()):</span>
        <span class="n">node_biparint_to_postorder_index</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="n">digit</span> <span class="o">=</span> <span class="n">taxon_labels_to_bitstr_digit</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span><span class="p">]</span>
            <span class="n">CountOnesSubtree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>  <span class="nb">int</span><span class="p">(</span><span class="n">b_bitstr</span><span class="p">[</span><span class="o">-</span> <span class="n">digit</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">CountZerosSubtree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">CountOnesSubtree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">child_node_iter</span><span class="p">():</span>
                <span class="n">CountOnesSubtree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">CountOnesSubtree</span><span class="p">[</span> <span class="n">node_biparint_to_postorder_index</span><span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()]</span> <span class="p">]</span>
                <span class="n">CountZerosSubtree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">CountZerosSubtree</span><span class="p">[</span> <span class="n">node_biparint_to_postorder_index</span><span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()]</span> <span class="p">]</span>
            <span class="n">actDist</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">CountZerosSubtree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">CountOnesSubtree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">actDist</span> <span class="o">&gt;</span> <span class="n">n_taxa</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">actDist</span> <span class="o">=</span> <span class="n">n_taxa</span> <span class="o">-</span> <span class="n">actDist</span>
            <span class="k">if</span> <span class="n">actDist</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">actDist</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">d</span>
    
    <span class="k">return</span> <span class="n">d</span>

<span class="k">def</span> <span class="nf">quartet_resolution</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">parent_dir</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">parent_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">conname</span> <span class="o">=</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">_randomname</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nwk&quot;</span>
        <span class="n">conname2</span> <span class="o">=</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">_randomname</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nwk&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">conname</span> <span class="o">=</span> <span class="n">parent_dir</span> <span class="o">+</span> <span class="s2">&quot;/__&quot;</span> <span class="o">+</span> <span class="n">_randomname</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nwk&quot;</span>
        <span class="n">conname2</span> <span class="o">=</span> <span class="n">parent_dir</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">_randomname</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nwk&quot;</span>
    <span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">path</span> <span class="o">=</span> <span class="n">conname</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;newick&quot;</span><span class="p">,</span> <span class="n">suppress_rooting</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">tree</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">path</span> <span class="o">=</span> <span class="n">conname2</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;newick&quot;</span><span class="p">,</span> <span class="n">suppress_rooting</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">p</span><span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="s2">&quot;quartet_dist&quot;</span><span class="p">,</span> <span class="s2">&quot;-v&quot;</span><span class="p">,</span> <span class="n">conname</span><span class="p">,</span> <span class="n">conname2</span><span class="p">],</span><span class="n">capture_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;number_of_leaves&quot;</span><span class="p">,</span> <span class="s2">&quot;number_of_all_quartets&quot;</span><span class="p">,</span> <span class="s2">&quot;quartet_dist&quot;</span><span class="p">,</span> <span class="s2">&quot;normalized_quartet_dist&quot;</span><span class="p">,</span> <span class="s2">&quot;number_of_resolved_quartets_agreed&quot;</span><span class="p">,</span> 
            <span class="s2">&quot;normalized_number_of_resolved_quartets_agreed&quot;</span><span class="p">,</span> <span class="s2">&quot;number_of_unresolved_quartets_agreed&quot;</span><span class="p">,</span> <span class="s2">&quot;normalized_number_of_unresolved_quaretets_agreed&quot;</span><span class="p">]</span>
    <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
    <span class="n">q_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">items</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;deleting now&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">[</span><span class="n">conname</span><span class="p">,</span><span class="n">conname2</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">normalized</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">q_dict</span><span class="p">[</span><span class="s2">&quot;number_of_all_quartets&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">q_dict</span><span class="p">[</span><span class="s2">&quot;number_of_unresolved_quartets_agreed&quot;</span><span class="p">])</span><span class="o">/</span><span class="n">q_dict</span><span class="p">[</span><span class="s2">&quot;number_of_all_quartets&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">q_dict</span><span class="p">[</span><span class="s2">&quot;number_of_all_quartets&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">q_dict</span><span class="p">[</span><span class="s2">&quot;number_of_unresolved_quartets_agreed&quot;</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">quartet_resolution2</span><span class="p">(</span><span class="n">tree_string</span><span class="p">,</span> <span class="n">parent_dir</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    
    <span class="k">if</span> <span class="n">parent_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">conname</span> <span class="o">=</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">_randomname</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nwk&quot;</span>
        <span class="n">conname2</span> <span class="o">=</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">_randomname</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nwk&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">conname</span> <span class="o">=</span> <span class="n">parent_dir</span> <span class="o">+</span> <span class="s2">&quot;/__&quot;</span> <span class="o">+</span> <span class="n">_randomname</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nwk&quot;</span>
        <span class="n">conname2</span> <span class="o">=</span> <span class="n">parent_dir</span> <span class="o">+</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">_randomname</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nwk&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">conname</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tree_string</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">conname2</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tree_string</span><span class="p">)</span>
    <span class="n">p</span><span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="s2">&quot;quartet_dist&quot;</span><span class="p">,</span> <span class="s2">&quot;-v&quot;</span><span class="p">,</span> <span class="n">conname</span><span class="p">,</span> <span class="n">conname2</span><span class="p">],</span><span class="n">capture_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;number_of_leaves&quot;</span><span class="p">,</span> <span class="s2">&quot;number_of_all_quartets&quot;</span><span class="p">,</span> <span class="s2">&quot;quartet_dist&quot;</span><span class="p">,</span> <span class="s2">&quot;normalized_quartet_dist&quot;</span><span class="p">,</span> <span class="s2">&quot;number_of_resolved_quartets_agreed&quot;</span><span class="p">,</span> 
            <span class="s2">&quot;normalized_number_of_resolved_quartets_agreed&quot;</span><span class="p">,</span> <span class="s2">&quot;number_of_unresolved_quartets_agreed&quot;</span><span class="p">,</span> <span class="s2">&quot;normalized_number_of_unresolved_quaretets_agreed&quot;</span><span class="p">]</span>
    <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
    <span class="c1">#q_dict = dict(zip(keys, items))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;deleting now&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">[</span><span class="n">conname</span><span class="p">,</span><span class="n">conname2</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="n">num_all_quartets</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">num_unresolved_quartets_agreed</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="mi">6</span><span class="p">::</span><span class="mi">8</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">normalized</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">num_all_quartets</span> <span class="o">-</span> <span class="n">num_unresolved_quartets_agreed</span><span class="p">)</span><span class="o">/</span><span class="n">num_all_quartets</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">num_all_quartets</span> <span class="o">-</span> <span class="n">num_unresolved_quartets_agreed</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">tqdist_fp_fn</span><span class="p">(</span><span class="n">estimate</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">parent_dir</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">executable_name</span> <span class="o">=</span> <span class="s1">&#39;pairs_quartet_dist&#39;</span>
    <span class="n">executable_path</span> <span class="o">=</span> <span class="n">shutil</span><span class="o">.</span><span class="n">which</span><span class="p">(</span><span class="n">executable_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">executable_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: &#39;</span><span class="si">{</span><span class="n">executable_name</span><span class="si">}</span><span class="s2">&#39; not found. You need to install tqDist package on your PATH.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#print(f&quot;Using executable &#39;{executable_name}&#39; found at {executable_path}...&quot;)</span>
        <span class="k">pass</span>
        <span class="c1"># Proceed with execution</span>
    <span class="k">if</span> <span class="n">parent_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">estimatename</span> <span class="o">=</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">_randomname</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nwk&quot;</span>
        <span class="n">truename</span> <span class="o">=</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">_randomname</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nwk&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">estimatename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">,</span>  <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">_randomname</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nwk&quot;</span><span class="p">)</span>
        <span class="n">truename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">,</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">_randomname</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nwk&quot;</span><span class="p">)</span>
    
    <span class="n">estimate</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">path</span> <span class="o">=</span> <span class="n">estimatename</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;newick&quot;</span><span class="p">,</span> <span class="n">suppress_rooting</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">true</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">path</span> <span class="o">=</span> <span class="n">truename</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;newick&quot;</span><span class="p">,</span> <span class="n">suppress_rooting</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>   
    
    <span class="n">p</span><span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="s2">&quot;quartet_dist&quot;</span><span class="p">,</span> <span class="s2">&quot;-v&quot;</span><span class="p">,</span> <span class="n">estimatename</span><span class="p">,</span> <span class="n">truename</span><span class="p">],</span><span class="n">capture_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;number_of_leaves&quot;</span><span class="p">,</span> <span class="s2">&quot;number_of_all_quartets&quot;</span><span class="p">,</span> <span class="s2">&quot;quartet_dist&quot;</span><span class="p">,</span> <span class="s2">&quot;normalized_quartet_dist&quot;</span><span class="p">,</span> <span class="s2">&quot;number_of_resolved_quartets_agreed&quot;</span><span class="p">,</span> 
            <span class="s2">&quot;normalized_number_of_resolved_quartets_agreed&quot;</span><span class="p">,</span> <span class="s2">&quot;number_of_unresolved_quartets_agreed&quot;</span><span class="p">,</span> <span class="s2">&quot;normalized_number_of_unresolved_quaretets_agreed&quot;</span><span class="p">]</span>
    <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
    <span class="n">tqdist_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">items</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">[</span><span class="n">estimatename</span><span class="p">,</span><span class="n">truename</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    
    <span class="c1"># check resolution</span>
    <span class="n">estimate_num_resolved</span> <span class="o">=</span> <span class="n">quartet_resolution</span><span class="p">(</span><span class="n">estimate</span><span class="p">,</span> <span class="n">parent_dir</span><span class="o">=</span><span class="n">parent_dir</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">estimate_num_unresolved</span> <span class="o">=</span> <span class="n">tqdist_dict</span><span class="p">[</span><span class="s2">&quot;number_of_all_quartets&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">estimate_num_resolved</span>
    <span class="n">true_num_resolved</span> <span class="o">=</span> <span class="n">quartet_resolution</span><span class="p">(</span><span class="n">true</span><span class="p">,</span> <span class="n">parent_dir</span><span class="o">=</span><span class="n">parent_dir</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">true_num_unresolved</span> <span class="o">=</span> <span class="n">tqdist_dict</span><span class="p">[</span><span class="s2">&quot;number_of_all_quartets&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">true_num_resolved</span>
    
    <span class="c1"># compute number of each component</span>
    <span class="n">unresolved_resolved_fn</span> <span class="o">=</span> <span class="n">estimate_num_unresolved</span> <span class="o">-</span>  <span class="n">tqdist_dict</span><span class="p">[</span><span class="s2">&quot;number_of_unresolved_quartets_agreed&quot;</span><span class="p">]</span>
    <span class="n">resolved_unresolved_fp</span> <span class="o">=</span> <span class="n">true_num_unresolved</span> <span class="o">-</span>  <span class="n">tqdist_dict</span><span class="p">[</span><span class="s2">&quot;number_of_unresolved_quartets_agreed&quot;</span><span class="p">]</span>
    <span class="n">resolved_resolved_disagree</span> <span class="o">=</span> <span class="n">estimate_num_resolved</span> <span class="o">-</span> <span class="n">resolved_unresolved_fp</span> <span class="o">-</span> <span class="n">tqdist_dict</span><span class="p">[</span><span class="s1">&#39;number_of_resolved_quartets_agreed&#39;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">resolved_resolved_disagree</span> <span class="o">==</span> <span class="p">(</span><span class="n">true_num_resolved</span> <span class="o">-</span> <span class="n">unresolved_resolved_fn</span> <span class="o">-</span> <span class="n">tqdist_dict</span><span class="p">[</span><span class="s1">&#39;number_of_resolved_quartets_agreed&#39;</span><span class="p">])</span>
    
    <span class="c1"># compute fn and fp</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="n">unresolved_resolved_fn</span> <span class="o">+</span> <span class="n">resolved_resolved_disagree</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">resolved_unresolved_fp</span> <span class="o">+</span> <span class="n">resolved_resolved_disagree</span>
    <span class="k">return</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fn</span>
    

<span class="k">def</span> <span class="nf">tqdist_fp_fn2</span><span class="p">(</span><span class="n">estimate</span><span class="p">,</span> <span class="n">input_trees_string</span><span class="p">,</span> <span class="n">n_trees</span><span class="p">,</span> <span class="n">parent_dir</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">executable_name</span> <span class="o">=</span> <span class="s1">&#39;pairs_quartet_dist&#39;</span>
    <span class="n">executable_path</span> <span class="o">=</span> <span class="n">shutil</span><span class="o">.</span><span class="n">which</span><span class="p">(</span><span class="n">executable_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">executable_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: &#39;</span><span class="si">{</span><span class="n">executable_name</span><span class="si">}</span><span class="s2">&#39; not found. You need to install tqDist package on your PATH.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#print(f&quot;Using executable &#39;{executable_name}&#39; found at {executable_path}...&quot;)</span>
        <span class="k">pass</span>
        <span class="c1"># Proceed with execution</span>
    <span class="k">if</span> <span class="n">parent_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">estimatename</span> <span class="o">=</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">_randomname</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nwk&quot;</span>
        <span class="n">truename</span> <span class="o">=</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">_randomname</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nwk&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">estimatename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">,</span>  <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">_randomname</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nwk&quot;</span><span class="p">)</span>
        <span class="n">truename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parent_dir</span><span class="p">,</span> <span class="s2">&quot;__&quot;</span> <span class="o">+</span> <span class="n">_randomname</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nwk&quot;</span><span class="p">)</span>
    <span class="n">estimate_string</span> <span class="o">=</span> <span class="n">estimate</span><span class="o">.</span><span class="n">as_string</span><span class="p">(</span><span class="n">schema</span><span class="o">=</span><span class="s2">&quot;newick&quot;</span><span class="p">,</span> <span class="n">suppress_rooting</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">estimatename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">estimate_string</span><span class="o">*</span><span class="n">n_trees</span><span class="p">)</span>
    <span class="n">estimate</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">path</span> <span class="o">=</span> <span class="n">estimatename</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;newick&quot;</span><span class="p">,</span> <span class="n">suppress_rooting</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">truename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">input_trees_string</span><span class="p">)</span>
    <span class="c1">#input_trees.write(path = truename, schema=&quot;newick&quot;, suppress_rooting=True)   </span>
    
    <span class="n">p</span><span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">([</span><span class="s2">&quot;pairs_quartet_dist&quot;</span><span class="p">,</span> <span class="s2">&quot;-v&quot;</span><span class="p">,</span> <span class="n">estimatename</span><span class="p">,</span> <span class="n">truename</span><span class="p">],</span><span class="n">capture_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># keys = [&quot;number_of_leaves&quot;, &quot;number_of_all_quartets&quot;, &quot;quartet_dist&quot;, &quot;normalized_quartet_dist&quot;, &quot;number_of_resolved_quartets_agreed&quot;, </span>
    <span class="c1">#         &quot;normalized_number_of_resolved_quartets_agreed&quot;, &quot;number_of_unresolved_quartets_agreed&quot;, &quot;normalized_number_of_unresolved_quaretets_agreed&quot;]</span>
    <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
    <span class="n">num_unresolved_quartets_agreed</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="mi">6</span><span class="p">::</span><span class="mi">8</span><span class="p">]</span>
    <span class="n">num_resolved_quartets_agreed</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="mi">4</span><span class="p">::</span><span class="mi">8</span><span class="p">]</span>
    
    <span class="n">num_all_quartets</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1">#tqdist_dict = dict(zip(keys, items))</span>
    
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">[</span><span class="n">estimatename</span><span class="p">,</span><span class="n">truename</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    
    <span class="c1"># check resolution</span>
    <span class="n">estimate_num_resolved</span> <span class="o">=</span> <span class="n">quartet_resolution</span><span class="p">(</span><span class="n">estimate</span><span class="p">,</span> <span class="n">parent_dir</span><span class="o">=</span><span class="n">parent_dir</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">estimate_num_unresolved</span> <span class="o">=</span> <span class="n">num_all_quartets</span> <span class="o">-</span> <span class="n">estimate_num_resolved</span>
    <span class="n">true_num_resolved</span> <span class="o">=</span> <span class="n">quartet_resolution2</span><span class="p">(</span><span class="n">input_trees_string</span><span class="p">,</span> <span class="n">parent_dir</span><span class="o">=</span><span class="n">parent_dir</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">true_num_unresolved</span> <span class="o">=</span> <span class="n">num_all_quartets</span> <span class="o">-</span> <span class="n">true_num_resolved</span>
    
    <span class="c1"># compute number of each component</span>
    <span class="n">unresolved_resolved_fn</span> <span class="o">=</span> <span class="n">estimate_num_unresolved</span> <span class="o">-</span>  <span class="n">num_unresolved_quartets_agreed</span>
    <span class="n">resolved_unresolved_fp</span> <span class="o">=</span> <span class="n">true_num_unresolved</span> <span class="o">-</span>  <span class="n">num_unresolved_quartets_agreed</span>
    <span class="n">resolved_resolved_disagree</span> <span class="o">=</span> <span class="n">estimate_num_resolved</span> <span class="o">-</span> <span class="n">resolved_unresolved_fp</span> <span class="o">-</span> <span class="n">num_resolved_quartets_agreed</span>
    <span class="k">assert</span> <span class="n">resolved_resolved_disagree</span> <span class="o">==</span> <span class="p">(</span><span class="n">true_num_resolved</span> <span class="o">-</span> <span class="n">unresolved_resolved_fn</span> <span class="o">-</span> <span class="n">num_resolved_quartets_agreed</span><span class="p">)</span>
    
    <span class="c1"># compute fn and fp</span>
    <span class="n">fn</span> <span class="o">=</span> <span class="n">unresolved_resolved_fn</span> <span class="o">+</span> <span class="n">resolved_resolved_disagree</span>
    <span class="n">fp</span> <span class="o">=</span> <span class="n">resolved_unresolved_fp</span> <span class="o">+</span> <span class="n">resolved_resolved_disagree</span>
    <span class="k">return</span> <span class="n">fp</span><span class="p">,</span> <span class="n">fn</span>

<span class="c1"># def tqdist_fp_fn2(consensus_tree, input_trees_string, n_trees, parent_dir = None):</span>
<span class="c1">#     # consensus_tree: one tree: can be non-binary</span>
<span class="c1">#     # input_trees_string: Newick String of trees: ASSUMED TO BE BINARY</span>
<span class="c1">#     # n_trees: number of input treess</span>
    
<span class="c1">#     n = n_trees # number of input trees</span>
    

<span class="c1">#     executable_name = &#39;pairs_quartet_dist&#39;</span>
<span class="c1">#     executable_path = shutil.which(executable_name)</span>

<span class="c1">#     if executable_path is None:</span>
<span class="c1">#         sys.exit(f&quot;Error: &#39;{executable_name}&#39; not found. You need to install tqDist package on your PATH.&quot;)</span>
<span class="c1">#     else:</span>
<span class="c1">#         #print(f&quot;Using executable &#39;{executable_name}&#39; found at {executable_path}...&quot;)</span>
<span class="c1">#         pass</span>
<span class="c1">#         # Proceed with execution</span>

<span class="c1">#     if parent_dir is None:</span>
<span class="c1">#         conname = &quot;__&quot; + _randomname(10) + &quot;.nwk&quot;</span>
<span class="c1">#         consname = &quot;__&quot; + _randomname(10) + &quot;.nwk&quot;</span>
<span class="c1">#         inputname = &quot;__&quot; + _randomname(10) + &quot;.nwk&quot;</span>
<span class="c1">#     else:</span>
<span class="c1">#         conname = os.path.join(parent_dir,  &quot;__&quot; + _randomname(10) + &quot;.nwk&quot;)</span>
<span class="c1">#         consname = os.path.join(parent_dir, &quot;__&quot; + _randomname(10) + &quot;.nwk&quot;)</span>
<span class="c1">#         inputname = os.path.join(parent_dir , &quot;__&quot; + _randomname(10) + &quot;.nwk&quot;)</span>

<span class="c1">#     try:</span>
<span class="c1">#         consensus_tree.write(path=conname, schema=&quot;newick&quot;, suppress_rooting = True)</span>
<span class="c1">#         # write n * consensus trees </span>
<span class="c1">#         consensus_nwk_str = consensus_tree.as_string(schema=&quot;newick&quot;, suppress_rooting = True)</span>
<span class="c1">#         with open(consname, &quot;w&quot;) as f:</span>
<span class="c1">#             f.write(consensus_nwk_str*n)</span>
        
<span class="c1">#         #write input trees</span>
<span class="c1">#         with open(inputname, &quot;w&quot;) as f:</span>
<span class="c1">#             f.write(input_trees_string)</span>
<span class="c1">#         #input_trees.write(path = &quot;__tmp__input.nwk&quot;, schema=&quot;newick&quot;, suppress_rooting=True)</span>
        
<span class="c1">#         # run pairs_quartet_dist</span>
<span class="c1">#         p= subprocess.run([&quot;pairs_quartet_dist&quot;, &quot;-v&quot;, consname, inputname],capture_output=True, text=True)</span>
<span class="c1">#         if p.stderr != &#39;&#39;:</span>
<span class="c1">#             print(&quot;error executing tqdist:&quot;, p.stderr)</span>
<span class="c1">#             sys.exit(1)</span>
<span class="c1">#         quartet_dist_list = [float(item) for item in p.stdout.split()][2::8]</span>
<span class="c1">#         quartet_dists = np.array(quartet_dist_list)</span>
        
        
<span class="c1">#         p2 = subprocess.run([&quot;quartet_dist&quot;, &quot;-v&quot;, conname, conname],capture_output=True, text=True)</span>
<span class="c1">#         if p2.stderr != &#39;&#39;:</span>
<span class="c1">#             print(&quot;error executing tqdist:&quot;, p2.stderr)</span>
<span class="c1">#             sys.exit(1)</span>
<span class="c1">#         consensus_num_unresolved = [float(item) for item in p2.stdout.split()][6]</span>
        
        
        
        
<span class="c1">#     p= subprocess.run([&quot;quartet_dist&quot;, &quot;-v&quot;, estimatename, truename],capture_output=True, text=True)</span>
<span class="c1">#     keys = [&quot;number_of_leaves&quot;, &quot;number_of_all_quartets&quot;, &quot;quartet_dist&quot;, &quot;normalized_quartet_dist&quot;, &quot;number_of_resolved_quartets_agreed&quot;, </span>
<span class="c1">#             &quot;normalized_number_of_resolved_quartets_agreed&quot;, &quot;number_of_unresolved_quartets_agreed&quot;, &quot;normalized_number_of_unresolved_quaretets_agreed&quot;]</span>
<span class="c1">#     items = [float(item) for item in p.stdout.split()]</span>
<span class="c1">#     tqdist_dict = dict(zip(keys, items))</span>
    
<span class="c1">#     for item in [estimatename,truename]:</span>
<span class="c1">#         if os.path.exists(item):</span>
<span class="c1">#             os.remove(item)</span>

    
<span class="c1">#     # check resolution</span>
<span class="c1">#     estimate_num_resolved = quartet_resolution(estimate, parent_dir=parent_dir, normalized=False)</span>
<span class="c1">#     estimate_num_unresolved = tqdist_dict[&quot;number_of_all_quartets&quot;] - estimate_num_resolved</span>
<span class="c1">#     true_num_resolved = quartet_resolution(true, parent_dir=parent_dir, normalized=False)</span>
<span class="c1">#     true_num_unresolved = tqdist_dict[&quot;number_of_all_quartets&quot;] - true_num_resolved</span>
    
<span class="c1">#     # compute number of each component</span>
<span class="c1">#     unresolved_resolved_fn = estimate_num_unresolved -  tqdist_dict[&quot;number_of_unresolved_quartets_agreed&quot;]</span>
<span class="c1">#     resolved_unresolved_fp = true_num_unresolved -  tqdist_dict[&quot;number_of_unresolved_quartets_agreed&quot;]</span>
<span class="c1">#     resolved_resolved_disagree = estimate_num_resolved - resolved_unresolved_fp - tqdist_dict[&#39;number_of_resolved_quartets_agreed&#39;]</span>
<span class="c1">#     assert resolved_resolved_disagree == (true_num_resolved - unresolved_resolved_fn - tqdist_dict[&#39;number_of_resolved_quartets_agreed&#39;])</span>
    
<span class="c1">#     # compute fn and fp</span>
<span class="c1">#     fn = unresolved_resolved_fn + resolved_resolved_disagree</span>
<span class="c1">#     fp = resolved_unresolved_fp + resolved_resolved_disagree</span>

<span class="c1">#         # get number of unresolved quartet trees</span>
<span class="c1">#         p2 = subprocess.run([&quot;pairs_quartet_dist&quot;, &quot;-v&quot;, conname, conname],capture_output=True, text=True)</span>
<span class="c1">#         if p2.stderr != &#39;&#39;:</span>
<span class="c1">#             print(&quot;error executing tqdist:&quot;, p2.stderr)</span>
<span class="c1">#             sys.exit(1)</span>
<span class="c1">#         num_unresolved = [float(item) for item in p2.stdout.split()][6]</span>

<span class="c1">#         num_unmatched_resolved = quartet_dists - num_unresolved # length n</span>
        
<span class="c1">#         fn = quartet_dists # =  num_unresolved + num_unmatched_resolved</span>
<span class="c1">#         fp = num_unmatched_resolved</span>
        
<span class="c1">#         for item in [conname, consname, inputname]:</span>
<span class="c1">#             if os.path.exists(item):</span>
<span class="c1">#                 os.remove(item)</span>
        
<span class="c1">#     except:</span>
<span class="c1">#         # delete temporary file</span>
<span class="c1">#         for item in [conname, consname, inputname]:</span>
<span class="c1">#             if os.path.exists(item):</span>
<span class="c1">#                 os.remove(item)</span>
<span class="c1">#         print(&quot;Error computing quartet distance.&quot;)</span>
<span class="c1">#         sys.exit(1)</span>

<span class="c1">#     return fp, fn</span>
  

<span class="k">def</span> <span class="nf">quartet_loss2</span><span class="p">(</span><span class="n">consensus_tree</span><span class="p">,</span> <span class="n">input_trees_string</span><span class="p">,</span> <span class="n">n_trees</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parent_dir</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="c1"># use tqdist&#39;s `pairs_quartet_dist` function</span>
    <span class="n">fp</span><span class="p">,</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">tqdist_fp_fn2</span><span class="p">(</span><span class="n">consensus_tree</span><span class="p">,</span> <span class="n">input_trees_string</span><span class="p">,</span> <span class="n">n_trees</span><span class="p">,</span> <span class="n">parent_dir</span><span class="p">)</span> <span class="c1"># fp, fn are ndarrays of length n=len(input_trees)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fp</span><span class="o">+</span><span class="n">fn</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">normalized</span><span class="p">:</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss</span><span class="o">/</span><span class="n">n_trees</span>
    <span class="k">return</span> <span class="n">loss</span>

<span class="k">def</span> <span class="nf">quartet_pruning</span><span class="p">(</span><span class="n">consensus_tree</span><span class="p">,</span> <span class="n">input_trees</span><span class="p">,</span> <span class="n">parent_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">bipartitions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">consensus_tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">())</span>
    <span class="n">bipartition_ints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span> <span class="k">for</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="n">bipartitions</span><span class="p">])</span>
    <span class="n">internal_edges</span> <span class="o">=</span> <span class="n">consensus_tree</span><span class="o">.</span><span class="n">internal_edges</span><span class="p">(</span><span class="n">exclude_seed_edge</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">internal_bipartitions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">internal_edges</span><span class="p">])</span>
    <span class="n">internal_bipartition_ints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span> <span class="k">for</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="n">internal_bipartitions</span><span class="p">])</span>
    <span class="n">internal_edge_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">():</span><span class="n">edge</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">internal_edges</span><span class="p">}</span>

    <span class="c1">#external_bipartition_dict = {bipar_int: all_bipartition_dict[bipar_int] for bipar_int in all_bipartition_dict.keys() if bipar_int not in internal_bipartitions}</span>
    <span class="c1">#external_bipartitions = np.array(list(external_bipartition_dict.values()))</span>

    <span class="c1">#mask = [True for i in range(len(bipartitions))]</span>
    <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">consensus_tree</span><span class="o">.</span><span class="n">taxon_namespace</span>
    <span class="n">trees_string</span> <span class="o">=</span> <span class="n">input_trees</span><span class="o">.</span><span class="n">as_string</span><span class="p">(</span><span class="s2">&quot;newick&quot;</span><span class="p">,</span> <span class="n">suppress_rooting</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">n_trees</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_trees</span><span class="p">)</span>
    <span class="n">current_loss</span> <span class="o">=</span> <span class="n">quartet_loss2</span><span class="p">(</span><span class="n">consensus_tree</span><span class="p">,</span> <span class="n">trees_string</span><span class="p">,</span> <span class="n">n_trees</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">parent_dir</span><span class="p">)</span>
    <span class="n">next_updates</span> <span class="o">=</span> <span class="n">internal_bipartition_ints</span>
    <span class="c1">#best_mask = [True for i in range(len(bipartitions))]</span>
    <span class="n">loss_reduction_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">bipar_int</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">bipar_int</span> <span class="ow">in</span> <span class="n">internal_bipartition_ints</span><span class="p">}</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">reduction_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">bipar_int</span> <span class="ow">in</span> <span class="n">next_updates</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bipar_int</span> <span class="ow">in</span> <span class="n">internal_bipartition_ints</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">bipar_int</span><span class="o">!=</span><span class="n">bipartition_ints</span>
                <span class="n">pruned_tree</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">Tree</span><span class="o">.</span><span class="n">from_bipartition_encoding</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">taxon_namespace</span><span class="o">=</span><span class="n">taxon_namespace</span><span class="p">)</span>
                <span class="n">loss</span> <span class="o">=</span> <span class="n">quartet_loss2</span><span class="p">(</span><span class="n">pruned_tree</span><span class="p">,</span> <span class="n">trees_string</span><span class="p">,</span> <span class="n">n_trees</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">parent_dir</span><span class="p">)</span>
                <span class="c1"># if current_loss - loss &gt; 0:</span>
                <span class="c1">#     print(f&quot;loss_reduction of {bipar_int}: &quot;, current_loss - loss)</span>
                <span class="n">loss_reduction_dict</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_loss</span> <span class="o">-</span> <span class="n">loss</span> <span class="c1"># if risk reduction happends, this is a positive value</span>
        
        <span class="c1"># look for edge that induces maximum risk reduction</span>
        <span class="n">max_key</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">loss_reduction_dict</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">loss_reduction_dict</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
        <span class="n">max_value</span> <span class="o">=</span> <span class="n">loss_reduction_dict</span><span class="p">[</span><span class="n">max_key</span><span class="p">]</span>
        <span class="c1"># print(f&quot;{max_key} will be pruned&quot;)</span>
        <span class="n">renew</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># if renew = True, prune. otherwise, don&#39;t prune.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">renew</span><span class="p">:</span>
            <span class="k">break</span> <span class="c1"># the current `consensus_tree` is the best</span>
        <span class="c1"># if renew, we continue</span>

        <span class="c1">## update next_updates</span>
        <span class="n">next_updates</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">internal_edge_dict</span><span class="p">[</span><span class="n">max_key</span><span class="p">]</span><span class="o">.</span><span class="n">adjacent_edges</span><span class="p">]</span>
        <span class="c1"># print(next_updates)</span>
        <span class="c1">## update other variables</span>
        <span class="n">best_mask</span> <span class="o">=</span> <span class="n">max_key</span><span class="o">!=</span><span class="n">bipartition_ints</span>
        <span class="n">consensus_tree</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">Tree</span><span class="o">.</span><span class="n">from_bipartition_encoding</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">[</span><span class="n">best_mask</span><span class="p">],</span> <span class="n">taxon_namespace</span><span class="o">=</span><span class="n">taxon_namespace</span><span class="p">)</span>
        <span class="n">bipartitions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">consensus_tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">())</span>
        <span class="n">bipartition_ints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span> <span class="k">for</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="n">bipartitions</span><span class="p">])</span>
        <span class="n">internal_edges</span> <span class="o">=</span> <span class="n">consensus_tree</span><span class="o">.</span><span class="n">internal_edges</span><span class="p">(</span><span class="n">exclude_seed_edge</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">internal_bipartitions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">internal_edges</span><span class="p">])</span>
        <span class="n">internal_bipartition_ints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span> <span class="k">for</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="n">internal_bipartitions</span><span class="p">])</span>
        <span class="n">internal_edge_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">edge</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">():</span><span class="n">edge</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">internal_edges</span><span class="p">}</span>
        <span class="n">current_loss</span> <span class="o">=</span> <span class="n">current_loss</span> <span class="o">-</span> <span class="n">max_value</span>
        <span class="n">loss_reduction_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">max_key</span><span class="p">)</span>
        <span class="n">ed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">reduction_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_value</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;iteration </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s2"> time: &quot;</span><span class="p">,</span> <span class="n">ed</span><span class="o">-</span><span class="n">st</span><span class="p">,</span> <span class="s2">&quot; risk reduction: &quot;</span><span class="p">,</span> <span class="n">max_value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">consensus_tree</span><span class="p">,</span> <span class="n">reduction_list</span>


<div class="viewcode-block" id="Tree_with_support">
<a class="viewcode-back" href="../../Consensus.html#Consensus.Tree_with_support">[docs]</a>
<span class="k">class</span> <span class="nc">Tree_with_support</span><span class="p">(</span><span class="n">dendropy</span><span class="o">.</span><span class="n">Tree</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Child class of `dendropy.datamodel.treemodel.Tree`, with supportfor support values.</span>
<span class="sd">    </span>
<span class="sd">    Attributes:</span>
<span class="sd">        x : 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">bootstrap_support</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;bootstrap_support&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">TBE_support</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;TBE_support&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_support</span> <span class="o">=</span> <span class="n">bootstrap_support</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span> <span class="o">=</span> <span class="n">TBE_support</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_taxa</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span> <span class="c1">#some methods (from_bipartitions etc) seem to produce a tree with bad bipartition_encoding, so renew it </span>

<div class="viewcode-block" id="Tree_with_support.compute_bootstrap">
<a class="viewcode-back" href="../../Consensus.html#Consensus.Tree_with_support.compute_bootstrap">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_bootstrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">treelist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute bootstrap values of self against input ``treelist`` and update `self.bootstrap_support`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        treelist : TreeList_with_support</span>
<span class="sd">            List of trees to evaluate bootstrap support against.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="o">==</span> <span class="n">treelist</span><span class="o">.</span><span class="n">taxon_namespace</span>
        <span class="n">bootstrap_support</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">bipar</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">bipar</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">treelist</span><span class="o">.</span><span class="n">edge_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">bootstrap_support</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">treelist</span><span class="o">.</span><span class="n">edge_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">treelist</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bootstrap_support</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_support</span> <span class="o">=</span> <span class="n">bootstrap_support</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    
    
<div class="viewcode-block" id="Tree_with_support.compute_TBE">
<a class="viewcode-back" href="../../Consensus.html#Consensus.Tree_with_support.compute_TBE">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_TBE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">treelist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute TBE support of self against input ``treelist`` and update `self.TBE_support`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        treelist : TreeList_with_support</span>
<span class="sd">            List of trees to evaluate TBE support against.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="o">==</span> <span class="n">treelist</span><span class="o">.</span><span class="n">taxon_namespace</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span>  <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
        <span class="n">bipartitions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bipartition_encoding</span>
        <span class="n">bipartitions_ints</span> <span class="o">=</span> <span class="p">[</span><span class="n">bipar</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span> <span class="k">for</span> <span class="n">bipar</span> <span class="ow">in</span> <span class="n">bipartitions</span><span class="p">]</span>
        <span class="n">TBE_list</span> <span class="o">=</span> <span class="n">TBE</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">,</span> <span class="n">treelist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">bipartitions_ints</span><span class="p">,</span> <span class="n">TBE_list</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Tree_with_support.clone">
<a class="viewcode-back" href="../../Consensus.html#Consensus.Tree_with_support.clone">[docs]</a>
    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;clone</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        depth : int, optional</span>
<span class="sd">            _description_, by default 1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _type_</span>
<span class="sd">            _description_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cloned_tree</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Tree_with_support</span><span class="p">(</span><span class="n">cloned_tree</span><span class="p">,</span> <span class="n">bootstrap_support</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_support</span><span class="p">,</span> <span class="n">TBE_support</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span><span class="p">)</span></div>

        

    <span class="k">def</span> <span class="nf">_make_Bio_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">support</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper function to convert self to Bio tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        support : dict or None, optional</span>
<span class="sd">            Support values to provide to Bio tree.   </span>
<span class="sd">            If dict, it should have integer representing each bipartition as key and support values as value.</span>
<span class="sd">            If None, no support values are provided to Bio tree.</span>
<span class="sd">            By default None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Bio.Phylo.Newick.Tree</span>
<span class="sd">            Newly created Bio tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree_Bio</span> <span class="o">=</span> <span class="n">Phylo</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">file</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_string</span><span class="p">(</span><span class="n">schema</span><span class="o">=</span><span class="s2">&quot;newick&quot;</span><span class="p">))</span> <span class="p">,</span> <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;newick&quot;</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">support</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">##### start -- add support information to each edge</span>
            <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">tree_Bio</span><span class="o">.</span><span class="n">find_clades</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;postorder&quot;</span><span class="p">):</span>
                <span class="n">terminals</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">clade</span><span class="o">.</span><span class="n">get_terminals</span><span class="p">()]</span>
                <span class="n">taxonnames_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">item</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">])</span>
                <span class="n">digits</span> <span class="o">=</span> <span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="n">item</span> <span class="o">==</span> <span class="n">taxonnames_array</span> <span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">terminals</span> <span class="p">]</span>
                <span class="n">clade_bool</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_taxa</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">digit</span> <span class="ow">in</span> <span class="n">digits</span><span class="p">:</span>
                    <span class="n">clade_bool</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">digit</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">clade_bit</span> <span class="o">=</span> <span class="n">Bits</span><span class="p">(</span><span class="n">clade_bool</span><span class="p">)</span> <span class="c1"># bitstring corresponding to the clade</span>
                <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">clade_bit</span><span class="o">.</span><span class="n">bin</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">clade_bit</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">clade_bit</span><span class="p">)</span> <span class="c1"># convert to least significant 0 format</span>
                <span class="k">if</span> <span class="n">clade_bit</span><span class="o">.</span><span class="n">uint</span> <span class="ow">in</span> <span class="n">support</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">clade_support</span> <span class="o">=</span> <span class="n">support</span><span class="p">[</span><span class="n">clade_bit</span><span class="o">.</span><span class="n">uint</span><span class="p">]</span>
                    <span class="n">clade</span><span class="o">.</span><span class="n">confidence</span> <span class="o">=</span> <span class="n">clade_support</span>
            <span class="c1">#####  end  -- add support information to each edge</span>
        <span class="k">return</span> <span class="n">tree_Bio</span>  

<div class="viewcode-block" id="Tree_with_support.plot_Bio">
<a class="viewcode-back" href="../../Consensus.html#Consensus.Tree_with_support.plot_Bio">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_Bio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">type</span> <span class="o">=</span> <span class="s2">&quot;plain&quot;</span><span class="p">,</span> <span class="n">decimals</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function to plot the tree using Bio.Phylo package.</span>
<span class="sd">        </span>
<span class="sd">        This function converts self to Bio.Phylo tree, and plot using Bio.Phylo&#39;s functionality.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ax : matplotlib.axes or None, optional</span>
<span class="sd">            Axes to plot the tree on. If None, new figure will be created.</span>
<span class="sd">        type : str, optional</span>
<span class="sd">            The type of support values to plot, by default &quot;plain&quot; (no support values are plotted).</span>
<span class="sd">            If not &quot;plain&quot;, it should be one of the followings:</span>
<span class="sd">            </span>
<span class="sd">            - &quot;bootstrap&quot; : bootstrap support</span>
<span class="sd">            - &quot;TBE&quot; : TBE support</span>
<span class="sd">            </span>
<span class="sd">            If these support values are not computed before calling this function, it will use the option &quot;plain&quot;.</span>
<span class="sd">            </span>
<span class="sd">            Please compute the support values beforehand.</span>
<span class="sd">        decimals : int or None, optional</span>
<span class="sd">            Decimal precision of support values, by default None (no rounding).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">## type: one of [&quot;plain&quot;, &quot;bootstrap&quot;, &quot;TBE&quot;]. If other name is provided, it will automatically plot &quot;plain&quot; one.</span>
        <span class="c1">## decimals: int, if provided, round confidence number at that number</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
        <span class="n">tree_Bio</span> <span class="o">=</span> <span class="n">Phylo</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">file</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_string</span><span class="p">(</span><span class="n">schema</span><span class="o">=</span><span class="s2">&quot;newick&quot;</span><span class="p">))</span> <span class="p">,</span> <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;newick&quot;</span> <span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;bootstrap&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_support</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Bootstrap values has not been provided to the instance. Plotting the plain tree.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">decimals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">boot</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_support</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">boot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_support</span>
            <span class="n">tree_Bio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_Bio_tree</span><span class="p">(</span><span class="n">boot</span><span class="p">)</span>
            <span class="n">Phylo</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span> <span class="n">tree_Bio</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">ax</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;TBE&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;TBE values has not been provided to the instance. Plotting the plain tree.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">decimals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tbe_supp</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tbe_supp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span>
            <span class="n">tree_Bio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_Bio_tree</span><span class="p">(</span><span class="n">tbe_supp</span><span class="p">)</span>
            <span class="n">Phylo</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span> <span class="n">tree_Bio</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">ax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tree_Bio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_Bio_tree</span><span class="p">()</span>
            <span class="n">Phylo</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span> <span class="n">tree_Bio</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">ax</span><span class="p">)</span> 
        <span class="k">return</span> <span class="n">ax</span></div>

    
<div class="viewcode-block" id="Tree_with_support.branch_resolution">
<a class="viewcode-back" href="../../Consensus.html#Consensus.Tree_with_support.branch_resolution">[docs]</a>
    <span class="k">def</span> <span class="nf">branch_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns branch resolution of self.</span>
<span class="sd">        </span>
<span class="sd">        The branch resolution is defined by:</span>
<span class="sd">        </span>
<span class="sd">        .. math::</span>

<span class="sd">            \\frac{\\text{# internal edges in self}}{\\text{self.n_taxa} - 3}</span>

<span class="sd">            </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _type_</span>
<span class="sd">            _description_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># returns how resolved tree is w.r.t. #internal branches</span>
        <span class="n">possible_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_taxa</span> <span class="o">-</span> <span class="mi">3</span> <span class="c1"># dendropy Tree stores n external edges + 1 external edge connecting to seed_node. There are n-3 internal edges.</span>
        <span class="n">internal_num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">internal_edges</span><span class="p">(</span><span class="n">exclude_seed_edge</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">internal_num</span> <span class="o">/</span> <span class="n">possible_num</span></div>


<div class="viewcode-block" id="Tree_with_support.std_greedy">
<a class="viewcode-back" href="../../Consensus.html#Consensus.Tree_with_support.std_greedy">[docs]</a>
    <span class="k">def</span> <span class="nf">std_greedy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">treelist</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply greedy pruning algorithm w.r.t. STD loss.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        treelist : TreeList_with_support</span>
<span class="sd">            Input trees to evaluate STD loss.</span>
<span class="sd">        normalized : bool, optional</span>
<span class="sd">            Whether to normalized STD loss, by default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tree_with_support</span>
<span class="sd">            Consensus tree after applying greedy pruning</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">self_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">srp</span> <span class="o">=</span> <span class="n">std_risk_prune</span><span class="p">(</span><span class="n">self_copy</span><span class="p">,</span> <span class="n">treelist</span><span class="p">,</span> <span class="n">normalized</span><span class="p">)</span>
        <span class="n">srp</span><span class="o">.</span><span class="n">greedy_pruning</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">srp</span><span class="o">.</span><span class="n">current_tree</span></div>

    
<div class="viewcode-block" id="Tree_with_support.sqd_greedy">
<a class="viewcode-back" href="../../Consensus.html#Consensus.Tree_with_support.sqd_greedy">[docs]</a>
    <span class="k">def</span> <span class="nf">sqd_greedy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">treelist</span><span class="p">,</span> <span class="n">parent_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply greedy pruning algorithm w.r.t. SQD loss.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        treelist : TreeList_with_support</span>
<span class="sd">            Input trees to evaluate SQD loss.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tree_with_support</span>
<span class="sd">            Consensus tree after applying greedy pruning</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">self_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">res</span><span class="p">,</span> <span class="n">reduction_list</span> <span class="o">=</span> <span class="n">quartet_pruning</span><span class="p">(</span><span class="n">self_copy</span><span class="p">,</span> <span class="n">treelist</span><span class="p">,</span> <span class="n">parent_dir</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>

    
<div class="viewcode-block" id="Tree_with_support.BS_prune">
<a class="viewcode-back" href="../../Consensus.html#Consensus.Tree_with_support.BS_prune">[docs]</a>
    <span class="k">def</span> <span class="nf">BS_prune</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">treelist</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prune all edges that has branch support &lt;= threshold.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        treelist : TreeList_with_support</span>
<span class="sd">            Input trees to compute branch support</span>
<span class="sd">        threshold : float, optional</span>
<span class="sd">            Threshold of branch support, by default 0.5</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tree_with_support</span>
<span class="sd">            Thresholded consensus</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_support</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_bootstrap</span><span class="p">(</span><span class="n">treelist</span><span class="p">)</span>
        
        <span class="n">bipars</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">bootstrap_support</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">();</span> <span class="n">TBE_support</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">():</span>
            <span class="n">splitint</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_support</span><span class="p">[</span><span class="n">splitint</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
                <span class="n">bipars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">bipartition</span><span class="p">)</span>
                <span class="n">bootstrap_support</span><span class="p">[</span><span class="n">splitint</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bootstrap_support</span><span class="p">[</span><span class="n">splitint</span><span class="p">]</span>
        <span class="n">thresholded</span> <span class="o">=</span> <span class="n">Tree_with_support</span><span class="p">(</span><span class="n">dendropy</span><span class="o">.</span><span class="n">Tree</span><span class="o">.</span><span class="n">from_bipartition_encoding</span><span class="p">(</span><span class="n">bipars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">),</span> <span class="n">bootstrap_support</span> <span class="o">=</span> <span class="n">bootstrap_support</span><span class="p">,</span> <span class="n">TBE_support</span> <span class="o">=</span> <span class="n">TBE_support</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">thresholded</span></div>

         
        
<div class="viewcode-block" id="Tree_with_support.get">
<a class="viewcode-back" href="../../Consensus.html#Consensus.Tree_with_support.get">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _type_</span>
<span class="sd">            _description_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">Tree</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">bootstrap_support</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;bootstrap_support&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">TBE_support</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;TBE_support&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">bootstrap_support</span> <span class="o">=</span> <span class="n">bootstrap_support</span><span class="p">,</span> <span class="n">TBE_support</span> <span class="o">=</span> <span class="n">TBE_support</span><span class="p">)</span></div>
</div>



<span class="k">def</span> <span class="nf">_minDist_and_match2</span><span class="p">(</span><span class="n">refinfo_b</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
    <span class="c1"># bipartition: Bipartition object</span>
    <span class="c1"># tree: Tree_with_support or Tree object</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">refinfo_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">b_bitstr</span> <span class="o">=</span> <span class="n">refinfo_b</span><span class="p">[</span><span class="o">-</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">matched</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">second_match</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1">#edge_bitstr = Bits(uint = bipartition.split_as_int(), length=self.n_taxa)</span>
    <span class="c1">#p = min(edge_bitstr.count(1), edge_bitstr.count(0))</span>
    <span class="c1">#m = len(tree.edge)</span>

    <span class="c1"># WE ASSUME THAT bipartition and tree has the exact same TAXON_NAMESPACE </span>
    <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">taxon_namespace</span>
    <span class="n">taxon_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">taxon</span> <span class="ow">in</span> <span class="n">taxon_namespace</span><span class="p">]</span>
    <span class="n">n_taxa</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">taxon_labels</span><span class="p">)</span>
    <span class="n">taxon_labels_to_bitstr_digit</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">taxon_labels</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_taxa</span><span class="p">)]))</span>
    <span class="n">node_biparint_to_postorder_index</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">bipartition_encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
    
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="p">)</span>
    <span class="n">CountOnesSubtree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">CountZerosSubtree</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">postorder_node_iter</span><span class="p">()):</span>
        <span class="n">node_biparint_to_postorder_index</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">():</span>
            <span class="n">digit</span> <span class="o">=</span> <span class="n">taxon_labels_to_bitstr_digit</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">taxon</span><span class="o">.</span><span class="n">label</span><span class="p">]</span>
            <span class="n">CountOnesSubtree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>  <span class="nb">int</span><span class="p">(</span><span class="n">b_bitstr</span><span class="p">[</span><span class="o">-</span> <span class="n">digit</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">CountZerosSubtree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">CountOnesSubtree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">child_node_iter</span><span class="p">():</span>
                <span class="n">CountOnesSubtree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">CountOnesSubtree</span><span class="p">[</span> <span class="n">node_biparint_to_postorder_index</span><span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()]</span> <span class="p">]</span>
                <span class="n">CountZerosSubtree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">CountZerosSubtree</span><span class="p">[</span> <span class="n">node_biparint_to_postorder_index</span><span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()]</span> <span class="p">]</span>
            <span class="n">actDist</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">CountZerosSubtree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">CountOnesSubtree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">actDist</span> <span class="o">&gt;</span> <span class="n">n_taxa</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">actDist</span> <span class="o">=</span> <span class="n">n_taxa</span> <span class="o">-</span> <span class="n">actDist</span>
            <span class="k">if</span> <span class="n">actDist</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">:</span>
                <span class="c1"># renew second match</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="n">d</span>
                <span class="n">second_match</span> <span class="o">=</span> <span class="n">matched</span>
                <span class="c1"># renew first match</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">actDist</span>
                <span class="n">matched</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">actDist</span> <span class="o">&lt;</span> <span class="n">d2</span><span class="p">:</span>
                <span class="c1"># renew only second match</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="n">actDist</span>
                <span class="n">second_match</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="n">matched</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">second_match</span>



<span class="k">def</span> <span class="nf">_TBE_and_match2</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span><span class="n">Tree_with_support</span><span class="p">):</span>
    <span class="n">n_taxa</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
    <span class="n">refinfo</span> <span class="o">=</span> <span class="n">_create_refinfo</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">,</span> <span class="n">n_taxa</span><span class="p">)</span>
    <span class="n">n_bipartitions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">)</span>
    <span class="n">totalSupport</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bipartitions</span><span class="p">)</span>
    <span class="n">secondSupport</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bipartitions</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">bipartition_encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
    <span class="n">tree_bipartition_ints</span> <span class="o">=</span> <span class="p">[</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span> <span class="k">for</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="p">]</span>
    <span class="n">matched_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">second_match_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">):</span>
        <span class="n">bipar_int</span> <span class="o">=</span> <span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">refinfo</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">support</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">matched</span><span class="o">=-</span><span class="mi">1</span>
            <span class="n">second_support</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">second_match</span><span class="o">=-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">bipar_int</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tree_bipartition_ints</span> <span class="ow">and</span> <span class="n">refinfo</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">support</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">matched</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">second_support</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">second_match</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dis</span><span class="p">,</span> <span class="n">matched</span><span class="p">,</span> <span class="n">dis2</span><span class="p">,</span> <span class="n">second_match</span> <span class="o">=</span> <span class="n">_minDist_and_match2</span><span class="p">(</span><span class="n">refinfo</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">],</span> <span class="n">tree</span><span class="p">)</span>
            <span class="n">support</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">dis</span> <span class="o">/</span> <span class="p">(</span><span class="n">refinfo</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">second_support</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">dis2</span> <span class="o">/</span> <span class="p">(</span><span class="n">refinfo</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">totalSupport</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">support</span>
        <span class="n">secondSupport</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">second_support</span>
        <span class="n">matched_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matched</span><span class="p">)</span>
        <span class="n">second_match_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">second_match</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">totalSupport</span><span class="p">,</span> <span class="n">matched_list</span><span class="p">,</span> <span class="n">secondSupport</span><span class="p">,</span> <span class="n">second_match_list</span>

<span class="k">def</span> <span class="nf">_unnormalized_TBE_and_match2</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span><span class="n">Tree_with_support</span><span class="p">):</span>
    <span class="n">n_taxa</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
    <span class="n">refinfo</span> <span class="o">=</span> <span class="n">_create_refinfo</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">,</span> <span class="n">n_taxa</span><span class="p">)</span>
    <span class="n">n_bipartitions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">)</span>
    <span class="n">totalDistance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bipartitions</span><span class="p">)</span>
    <span class="n">secondDistance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_bipartitions</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">bipartition_encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
    <span class="n">tree_bipartition_ints</span> <span class="o">=</span> <span class="p">[</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span> <span class="k">for</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">bipartition_encoding</span><span class="p">]</span>
    <span class="n">matched_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">second_match_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">):</span>
        <span class="n">bipar_int</span> <span class="o">=</span> <span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">refinfo</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">distance</span><span class="o">=</span><span class="mi">0</span>
            <span class="n">matched</span><span class="o">=-</span><span class="mi">1</span>
            <span class="n">second_distance</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">second_match</span><span class="o">=-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">bipar_int</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tree_bipartition_ints</span> <span class="ow">and</span> <span class="n">refinfo</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">matched</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">second_distance</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">second_match</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distance</span><span class="p">,</span> <span class="n">matched</span><span class="p">,</span> <span class="n">second_distance</span><span class="p">,</span> <span class="n">second_match</span> <span class="o">=</span> <span class="n">_minDist_and_match2</span><span class="p">(</span><span class="n">refinfo</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">],</span> <span class="n">tree</span><span class="p">)</span>
            <span class="c1">#support = 1 - dis / (refinfo[bipar_int][1] - 1)</span>
            <span class="c1">#second_support = 1 - dis2 / (refinfo[bipar_int][1] - 1)</span>
        <span class="n">totalDistance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
        <span class="n">secondDistance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">second_distance</span>
        <span class="n">matched_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matched</span><span class="p">)</span>
        <span class="n">second_match_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">second_match</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">totalDistance</span><span class="p">,</span> <span class="n">matched_list</span><span class="p">,</span> <span class="n">secondDistance</span><span class="p">,</span> <span class="n">second_match_list</span>




<span class="k">class</span> <span class="nc">std_risk_prune</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_tree</span><span class="p">,</span> <span class="n">trees</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_tree</span> <span class="o">=</span> <span class="n">initial_tree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trees</span> <span class="o">=</span> <span class="n">trees</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_trees</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span><span class="o">=</span><span class="n">normalized</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tree</span><span class="o">.</span><span class="n">taxon_namespace</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">trees</span><span class="o">.</span><span class="n">taxon_namespace</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tree</span><span class="o">.</span><span class="n">bipartition_encoding</span>  <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
        <span class="n">bipartitions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tree</span><span class="o">.</span><span class="n">bipartition_encoding</span>
        <span class="n">bipartition_ints</span> <span class="o">=</span> <span class="p">[</span><span class="n">bipar</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span> <span class="k">for</span> <span class="n">bipar</span> <span class="ow">in</span> <span class="n">bipartitions</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;computing TBE...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normalized</span><span class="p">:</span>
            <span class="n">TBE_list</span> <span class="o">=</span> <span class="n">TBE</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trees</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">TBE_list</span> <span class="o">=</span> <span class="n">unnormalized_TBE</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trees</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">bipartition_ints</span><span class="p">,</span> <span class="n">TBE_list</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">normalized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="mi">1</span><span class="o">-</span><span class="n">support</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">support</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trees</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">support</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">support</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trees</span>
        <span class="c1"># use edge dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trees</span><span class="o">.</span><span class="n">edge_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trees_bipartition_ints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trees_bipartitions</span> <span class="o">=</span> <span class="p">[</span><span class="n">dendropy</span><span class="o">.</span><span class="n">Bipartition</span><span class="p">(</span><span class="n">leafset_bitmask</span> <span class="o">=</span> <span class="n">item</span><span class="p">,</span> <span class="n">tree_leafset_bitmask</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">current_tree</span><span class="o">.</span><span class="n">n_taxa</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trees_bipartition_ints</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;computing TBE for the other side...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normalized</span><span class="p">:</span>
            <span class="n">supports</span><span class="p">,</span> <span class="n">matched_list</span><span class="p">,</span> <span class="n">second_supports</span><span class="p">,</span> <span class="n">second_matched_list</span> <span class="o">=</span> <span class="n">_TBE_and_match2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trees_bipartitions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tree</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">supports</span><span class="p">,</span> <span class="n">matched_list</span><span class="p">,</span> <span class="n">second_supports</span><span class="p">,</span> <span class="n">second_matched_list</span> <span class="o">=</span> <span class="n">_unnormalized_TBE_and_match2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trees_bipartitions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tree</span><span class="p">)</span>

        <span class="c1"># initialize match_dict, reverse_match_dict, </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="p">[</span><span class="nb">list</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span><span class="p">))]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second_match_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="p">[</span><span class="nb">list</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span><span class="p">))]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_match_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trees_bipartition_ints</span><span class="p">,</span> <span class="p">[</span><span class="nb">list</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trees_bipartition_ints</span><span class="p">))]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_dict</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second_match_dict</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trees_bipartition_ints</span><span class="p">)):</span>
            <span class="n">bipar_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trees_bipartition_ints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">matched</span> <span class="o">=</span> <span class="n">matched_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">second_matched</span> <span class="o">=</span> <span class="n">second_matched_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_dict</span><span class="p">[</span><span class="n">matched</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bipar_int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">second_match_dict</span><span class="p">[</span><span class="n">second_matched</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bipar_int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reverse_match_dict</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">matched</span><span class="p">,</span> <span class="n">second_matched</span><span class="p">]</span>

        <span class="c1"># intialize rsupp_dict, second_supp_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rsupp_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trees_bipartition_ints</span><span class="p">,</span> <span class="n">supports</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second_supp_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trees_bipartition_ints</span><span class="p">,</span> <span class="n">second_supports</span><span class="p">))</span>
        <span class="c1"># intialize fn_dict</span>
        <span class="k">if</span> <span class="n">normalized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">item</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rsupp_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span> <span class="n">item</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rsupp_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">])</span>

    <span class="k">def</span> <span class="nf">find_risk_reduction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prune_bipar_int</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span><span class="p">:</span>
            <span class="n">fp_reduction</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span><span class="p">[</span><span class="n">prune_bipar_int</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trees</span> <span class="c1">#positive value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fp_reduction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span><span class="p">[</span><span class="n">prune_bipar_int</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trees</span>
        <span class="c1"># compute fn_increase</span>
        <span class="c1">## identify bipartitions that needs rematch</span>
        <span class="n">matched_bipars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_dict</span><span class="p">[</span><span class="n">prune_bipar_int</span><span class="p">]</span>
        <span class="c1">#rematch_bipartitions = [item for item in self.trees_bipartitions if item.split_as_int() in matched_bipars]</span>
        
        <span class="c1"># compute support difference</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span><span class="p">:</span>
            <span class="n">fn_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rsupp_dict</span><span class="p">[</span><span class="n">matched_bipars</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_supp_dict</span><span class="p">[</span><span class="n">matched_bipars</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_dict</span><span class="p">[</span><span class="n">matched_bipars</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> 
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matched_bipars</span><span class="p">))])</span> <span class="c1"># positive value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fn_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">second_supp_dict</span><span class="p">[</span><span class="n">matched_bipars</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rsupp_dict</span><span class="p">[</span><span class="n">matched_bipars</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_dict</span><span class="p">[</span><span class="n">matched_bipars</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> 
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matched_bipars</span><span class="p">))])</span> <span class="c1"># positive value</span>

        <span class="k">return</span> <span class="n">fp_reduction</span> <span class="o">-</span> <span class="n">fn_diff</span>
    
    <span class="k">def</span> <span class="nf">prune</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prune_bipar_int</span><span class="p">):</span>
        <span class="c1">#print(&quot;before prune rsupp: &quot;, self.rsupp_dict[3713820117856141855489523712], &quot;second: &quot;, self.second_supp_dict[3713820117856141855489523712])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span><span class="p">:</span>
            <span class="n">fp_reduction</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span><span class="p">[</span><span class="n">prune_bipar_int</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trees</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fp_reduction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span><span class="p">[</span><span class="n">prune_bipar_int</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trees</span>
        <span class="n">matched_bipars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_dict</span><span class="p">[</span><span class="n">prune_bipar_int</span><span class="p">]</span>
        <span class="n">rematch_bipartitions</span> <span class="o">=</span> <span class="p">{</span><span class="n">item</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">():</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trees_bipartitions</span> <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span> <span class="ow">in</span> <span class="n">matched_bipars</span><span class="p">}</span>
        <span class="n">rematch_bipartitions</span> <span class="o">=</span> <span class="p">[</span><span class="n">rematch_bipartitions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">matched_bipars</span><span class="p">]</span>
        <span class="n">second_matched_bipars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_match_dict</span><span class="p">[</span><span class="n">prune_bipar_int</span><span class="p">]</span>
        <span class="n">second_rematch_bipartitions</span> <span class="o">=</span> <span class="p">{</span><span class="n">item</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">():</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trees_bipartitions</span> <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span> <span class="ow">in</span> <span class="n">second_matched_bipars</span><span class="p">}</span>
        <span class="n">second_rematch_bipartitions</span> <span class="o">=</span> <span class="p">[</span><span class="n">second_rematch_bipartitions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">second_matched_bipars</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span><span class="p">:</span>
            <span class="n">fn_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rsupp_dict</span><span class="p">[</span><span class="n">matched_bipars</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_supp_dict</span><span class="p">[</span><span class="n">matched_bipars</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_dict</span><span class="p">[</span><span class="n">matched_bipars</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> 
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matched_bipars</span><span class="p">))])</span> <span class="c1"># positive value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fn_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">second_supp_dict</span><span class="p">[</span><span class="n">matched_bipars</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rsupp_dict</span><span class="p">[</span><span class="n">matched_bipars</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_dict</span><span class="p">[</span><span class="n">matched_bipars</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> 
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matched_bipars</span><span class="p">))])</span> <span class="c1"># positive value</span>
        <span class="n">new_bipartitions</span> <span class="o">=</span> <span class="p">[</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">bipar</span><span class="p">)</span> <span class="k">for</span> <span class="n">bipar</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tree</span><span class="o">.</span><span class="n">bipartition_encoding</span> <span class="k">if</span> <span class="n">bipar</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span><span class="o">!=</span><span class="n">prune_bipar_int</span><span class="p">]</span>
        <span class="n">new_tree</span> <span class="o">=</span> <span class="n">Tree_with_support</span><span class="p">(</span><span class="n">dendropy</span><span class="o">.</span><span class="n">Tree</span><span class="o">.</span><span class="n">from_bipartition_encoding</span><span class="p">(</span><span class="n">new_bipartitions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tree</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">),</span>
                                        <span class="n">TBE_support</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_tree</span> <span class="o">=</span> <span class="n">new_tree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">prune_bipar_int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="o">-</span> <span class="n">fp_reduction</span>
        <span class="c1">#print(&quot;fp diff:&quot;, np.sum([1-support for key, support in self.TBE_support.items()]) * self.n_trees - self.fp)</span>

        <span class="c1"># run matching for rematch_bipartitions.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span><span class="p">:</span>
            <span class="n">supports</span><span class="p">,</span> <span class="n">matched_list</span><span class="p">,</span> <span class="n">second_supports</span><span class="p">,</span> <span class="n">second_matched_list</span> <span class="o">=</span> <span class="n">_TBE_and_match2</span><span class="p">(</span><span class="n">rematch_bipartitions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tree</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">supports</span><span class="p">,</span> <span class="n">matched_list</span><span class="p">,</span> <span class="n">second_supports</span><span class="p">,</span> <span class="n">second_matched_list</span> <span class="o">=</span> <span class="n">_unnormalized_TBE_and_match2</span><span class="p">(</span><span class="n">rematch_bipartitions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tree</span><span class="p">)</span>
    
        <span class="c1"># renew match dict, second_match_dict, and reverse_match_dict and second_match_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">prune_bipar_int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">matched_bipars</span><span class="p">)):</span>
            <span class="n">bipar_int</span> <span class="o">=</span> <span class="n">matched_bipars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">original_first_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_match_dict</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">original_second_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_match_dict</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reverse_match_dict</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">matched_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">second_matched_list</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_dict</span><span class="p">[</span><span class="n">matched_list</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bipar_int</span><span class="p">)</span> <span class="c1"># set the newly matched one</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">second_match_dict</span><span class="p">[</span><span class="n">original_second_match</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">bipar_int</span><span class="p">)</span> <span class="c1"># remove from original second match bipar_int</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">second_match_dict</span><span class="p">[</span><span class="n">second_matched_list</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bipar_int</span><span class="p">)</span>
            <span class="c1"># renew supports</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">second_supp_dict</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">]</span> <span class="o">-</span> <span class="n">supports</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;bad second support&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_supp_dict</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">],</span> <span class="n">supports</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">bipar_int</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">matched_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">second_matched_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">original_first_match</span><span class="p">,</span> <span class="n">original_second_match</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rsupp_dict</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">supports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">second_supp_dict</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">second_supports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalized</span><span class="p">:</span>
            <span class="n">supports</span><span class="p">,</span> <span class="n">matched_list</span><span class="p">,</span> <span class="n">second_supports</span><span class="p">,</span> <span class="n">second_matched_list</span> <span class="o">=</span> <span class="n">_TBE_and_match2</span><span class="p">(</span><span class="n">second_rematch_bipartitions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tree</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">supports</span><span class="p">,</span> <span class="n">matched_list</span><span class="p">,</span> <span class="n">second_supports</span><span class="p">,</span> <span class="n">second_matched_list</span> <span class="o">=</span> <span class="n">_unnormalized_TBE_and_match2</span><span class="p">(</span><span class="n">second_rematch_bipartitions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_tree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second_match_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">prune_bipar_int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">second_matched_bipars</span><span class="p">)):</span>
            <span class="n">bipar_int</span> <span class="o">=</span> <span class="n">second_matched_bipars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">first_match</span> <span class="o">=</span> <span class="n">matched_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">second_match</span> <span class="o">=</span> <span class="n">second_matched_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">second_support</span> <span class="o">=</span> <span class="n">second_supports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">first_match</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_match_dict</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;different first match&quot;</span><span class="p">)</span>
                <span class="n">first_match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_match_dict</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">second_match</span> <span class="o">=</span> <span class="n">first_match</span> <span class="c1"># this way we don&#39;t have to modify the first match</span>
                <span class="n">second_support</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rsupp_dict</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reverse_match_dict</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">second_match</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">second_match_dict</span><span class="p">[</span><span class="n">second_match</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bipar_int</span><span class="p">)</span> <span class="c1"># add new second match</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">second_supp_dict</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">second_support</span>

        <span class="c1">#print(&quot;rsupp: &quot;, self.rsupp_dict[3713820117856141855489523712], &quot;second: &quot;, self.second_supp_dict[3713820117856141855489523712])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">+</span> <span class="n">fn_diff</span>
        <span class="c1">#print(&quot;fn diff:&quot;, np.sum([ (1-item) * self.edge_dict[key] for key, item in self.rsupp_dict.items() ]) - self.fn)</span>
    

    <span class="k">def</span> <span class="nf">greedy_pruning</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">bipartition_ints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TBE_support</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;current risk:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fp</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">)</span>
            <span class="c1"># find risk reduction</span>
            <span class="n">risk_reductions</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">find_risk_reduction</span><span class="p">(</span><span class="n">bipar_int</span><span class="p">)</span> <span class="k">for</span> <span class="n">bipar_int</span> <span class="ow">in</span> <span class="n">bipartition_ints</span><span class="p">]</span>
            <span class="n">max_risk_reduction_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">risk_reductions</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">risk_reductions</span><span class="p">[</span><span class="n">max_risk_reduction_index</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># risk reduction does not happen, so break</span>
                <span class="k">break</span>
            <span class="c1"># edge with max risk reduction will be removed.</span>
            <span class="n">prune_bipar</span> <span class="o">=</span> <span class="n">bipartition_ints</span><span class="p">[</span><span class="n">max_risk_reduction_index</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prune</span><span class="p">(</span><span class="n">prune_bipar</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_randomname</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
   <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">n</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_compatible</span><span class="p">(</span><span class="n">bits_a</span> <span class="p">:</span> <span class="n">Bits</span><span class="p">,</span> <span class="n">bits_b</span> <span class="p">:</span> <span class="n">Bits</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if two bitsting represented clades are compatible.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bits_a : Bits</span>
<span class="sd">        Bitstring representation of first bipartition.</span>
<span class="sd">    bits_b : Bits</span>
<span class="sd">        Bitstring representation of second bipartition.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        1 indicates compatible, 0 indicates incompatible.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">count1</span> <span class="o">=</span> <span class="p">(</span> <span class="n">bits_a</span> <span class="o">&amp;</span> <span class="n">bits_b</span> <span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">count2</span> <span class="o">=</span> <span class="p">((</span><span class="o">~</span><span class="n">bits_a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">bits_b</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">count3</span> <span class="o">=</span> <span class="p">(</span><span class="n">bits_a</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">bits_b</span><span class="p">))</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">count4</span> <span class="o">=</span> <span class="p">((</span><span class="o">~</span><span class="n">bits_a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">bits_b</span><span class="p">))</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">count1</span><span class="p">,</span> <span class="n">count2</span><span class="p">,</span> <span class="n">count3</span><span class="p">,</span> <span class="n">count4</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="c1"># compatible</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="c1"># incompatible</span>

<span class="k">def</span> <span class="nf">_Rstar</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span><span class="n">root_name</span> <span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes R* consensus tree using Bio.Phylo package.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trees : Iterable of Bio.Phylo.Newick.Tree</span>
<span class="sd">        Input trees to compute R* consensus.</span>
<span class="sd">    root_name : str</span>
<span class="sd">        Name of the root node picked.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Bio.Phylo.Newick.Tree</span>
<span class="sd">        R* consensus tree</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># root: clade instance of the leaf we make a root.</span>
    <span class="c1"># currently very inefficient and messy</span>
    <span class="n">rooted_trees</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
        <span class="n">rooted_tree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="n">terminals</span> <span class="o">=</span> <span class="n">rooted_tree</span><span class="o">.</span><span class="n">get_terminals</span><span class="p">()</span>
        <span class="n">root_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">terminals</span><span class="p">])</span> <span class="o">==</span> <span class="n">root_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">terminals</span><span class="p">[</span><span class="n">root_ind</span><span class="p">]</span>
        <span class="n">rooted_tree</span><span class="o">.</span><span class="n">root_with_outgroup</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="n">rooted_tree</span><span class="o">.</span><span class="n">prune</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="n">rooted_trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rooted_tree</span><span class="p">)</span>
    
    <span class="n">all_taxa_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">rooted_trees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_terminals</span><span class="p">()]</span>
    <span class="n">all_taxa_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_taxa_list</span><span class="p">)</span>

    
    <span class="c1"># Initialization: dict_RT_count O(n^3)</span>
    <span class="n">dict_RT_count</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">combi</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">all_taxa_list</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="n">dict_RT_count</span><span class="p">[</span> <span class="p">(</span> <span class="nb">frozenset</span><span class="p">((</span><span class="n">combi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">combi</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">,</span><span class="n">combi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dict_RT_count</span><span class="p">[</span> <span class="p">(</span> <span class="nb">frozenset</span><span class="p">((</span><span class="n">combi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">combi</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="p">,</span><span class="n">combi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dict_RT_count</span><span class="p">[</span> <span class="p">(</span> <span class="nb">frozenset</span><span class="p">((</span><span class="n">combi</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">combi</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">,</span><span class="n">combi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># For each tree, we traverse by DFS and add counts of rooted triples O(Kn^3)</span>
    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">rooted_trees</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">find_clades</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;postorder&quot;</span><span class="p">):</span>
            <span class="n">nonterminals</span> <span class="o">=</span> <span class="n">clade</span><span class="o">.</span><span class="n">get_nonterminals</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nonterminals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span> <span class="c1"># leaf clade</span>
            
            <span class="c1"># obtain the list of subtrees</span>
            <span class="n">subtree_list</span> <span class="o">=</span> <span class="n">clade</span><span class="o">.</span><span class="n">clades</span>
            <span class="c1"># obtain list of list of taxon in each subtree</span>
            <span class="n">subtree_taxa_list</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span>  <span class="n">tr</span><span class="o">.</span><span class="n">get_terminals</span><span class="p">()]</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">subtree_list</span><span class="p">]</span>
            <span class="c1"># set of taxon in this current clade and the other side of bipartition</span>
            <span class="n">taxa_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">clade</span><span class="o">.</span><span class="n">get_terminals</span><span class="p">()}</span>
            <span class="n">taxa_other</span> <span class="o">=</span> <span class="n">all_taxa_set</span> <span class="o">-</span> <span class="n">taxa_set</span>
            <span class="c1"># if this corresponds to root, skip</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">taxa_other</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">st_a</span><span class="p">,</span> <span class="n">st_b</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">subtree_taxa_list</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">taxon_a</span> <span class="ow">in</span> <span class="n">st_a</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">taxon_b</span> <span class="ow">in</span> <span class="n">st_b</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">taxon_c</span> <span class="ow">in</span> <span class="n">taxa_other</span><span class="p">:</span>
                            <span class="c1"># add count of (a,b)|c</span>
                            <span class="n">dict_RT_count</span><span class="p">[(</span><span class="nb">frozenset</span><span class="p">({</span><span class="n">taxon_a</span><span class="p">,</span> <span class="n">taxon_b</span><span class="p">}),</span> <span class="n">taxon_c</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Initialization of Rmaj</span>
    <span class="c1">#print(np.max(list(dict_RT_count.values())))</span>
    <span class="n">Rmaj</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">combi</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">all_taxa_set</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">Rmaj</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">({</span><span class="n">combi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">combi</span><span class="p">[</span><span class="mi">1</span><span class="p">]})]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="c1"># again iterate over all rooted triples</span>
    <span class="k">for</span> <span class="n">combi</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">all_taxa_set</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="n">count_0</span> <span class="o">=</span> <span class="n">dict_RT_count</span><span class="p">[(</span><span class="nb">frozenset</span><span class="p">({</span><span class="n">combi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">combi</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span> <span class="p">,</span> <span class="n">combi</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
        <span class="n">count_1</span> <span class="o">=</span> <span class="n">dict_RT_count</span><span class="p">[(</span><span class="nb">frozenset</span><span class="p">({</span><span class="n">combi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">combi</span><span class="p">[</span><span class="mi">2</span><span class="p">]})</span> <span class="p">,</span> <span class="n">combi</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="n">count_2</span> <span class="o">=</span> <span class="n">dict_RT_count</span><span class="p">[(</span><span class="nb">frozenset</span><span class="p">({</span><span class="n">combi</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">combi</span><span class="p">[</span><span class="mi">0</span><span class="p">]})</span> <span class="p">,</span> <span class="n">combi</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="p">[</span><span class="n">count_0</span><span class="p">,</span> <span class="n">count_1</span><span class="p">,</span> <span class="n">count_2</span><span class="p">]</span>
        <span class="n">argmax_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">counts</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">counts</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">argmax_ind</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># multiple candidates, so add nothing to Rmaj</span>
            <span class="k">continue</span>
        <span class="c1"># else, add to Rmaj</span>
        <span class="n">Rmaj</span><span class="p">[</span> <span class="nb">frozenset</span><span class="p">(</span> <span class="p">{</span> <span class="n">combi</span><span class="p">[</span><span class="n">argmax_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">combi</span><span class="p">[(</span><span class="n">argmax_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span> <span class="p">]</span> <span class="p">}</span> <span class="p">)</span> <span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">combi</span><span class="p">[(</span><span class="n">argmax_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">n_taxa</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_taxa_list</span><span class="p">)</span>
    <span class="n">s_maj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_taxa</span><span class="p">)])</span><span class="c1"># initialization</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">n_taxa</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">s_maj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_maj</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">Rmaj</span><span class="p">[</span> <span class="nb">frozenset</span><span class="p">(</span> <span class="p">{</span> <span class="n">all_taxa_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">all_taxa_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">}</span> <span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
    <span class="n">condensed_similarity</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">s_maj</span><span class="p">,</span> <span class="n">checks</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># condensed SIMILARITY matrix</span>
    <span class="n">condensed_dissimilarity</span> <span class="o">=</span> <span class="o">-</span> <span class="n">condensed_similarity</span> <span class="o">+</span> <span class="n">n_taxa</span> <span class="c1"># transforming into nonnegative value as well</span>
    <span class="n">linkage_matrix</span> <span class="o">=</span> <span class="n">linkage</span><span class="p">(</span><span class="n">condensed_dissimilarity</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;single&quot;</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;IGNORED&quot;</span><span class="p">)</span>
    <span class="n">slink_tree</span> <span class="o">=</span> <span class="n">to_tree</span><span class="p">(</span><span class="n">linkage_matrix</span><span class="p">)</span>
    <span class="n">slink_newick</span> <span class="o">=</span> <span class="n">_get_newick</span><span class="p">(</span><span class="n">slink_tree</span><span class="p">,</span> <span class="n">slink_tree</span><span class="o">.</span><span class="n">dist</span><span class="p">,</span> <span class="n">leaf_names</span><span class="o">=</span><span class="n">all_taxa_list</span><span class="p">)</span>
    <span class="n">slink</span> <span class="o">=</span> <span class="n">Phylo</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">slink_newick</span><span class="p">),</span> <span class="s2">&quot;newick&quot;</span><span class="p">)</span>
    <span class="c1">#unit branch length version</span>
    <span class="n">slink_unit</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">slink</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">slink_unit</span><span class="o">.</span><span class="n">find_clades</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">clade</span><span class="o">.</span><span class="n">branch_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">clade</span><span class="o">.</span><span class="n">branch_length</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">collapse_clades</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">clade</span> <span class="ow">in</span> <span class="n">slink_unit</span><span class="o">.</span><span class="n">find_clades</span><span class="p">(</span><span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;postorder&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">clade</span><span class="o">.</span><span class="n">is_terminal</span><span class="p">():</span>
            <span class="c1"># leaf node</span>
            <span class="k">continue</span>
        <span class="n">terminals</span> <span class="o">=</span> <span class="p">{</span><span class="n">item</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">clade</span><span class="o">.</span><span class="n">get_terminals</span><span class="p">()}</span>
        <span class="n">outsiders</span> <span class="o">=</span> <span class="n">all_taxa_set</span> <span class="o">-</span> <span class="n">terminals</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outsiders</span><span class="p">)</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># trivial clade</span>
            <span class="k">continue</span>
        <span class="n">end</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">terminals</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">outsiders</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Rmaj</span><span class="p">[</span> <span class="nb">frozenset</span><span class="p">(</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">}</span> <span class="p">)</span> <span class="p">]:</span>
                    <span class="n">collapse_clades</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clade</span><span class="p">)</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">end</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="n">slink_unit</span><span class="o">.</span><span class="n">collapse_all</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">collapse_clades</span><span class="p">)</span>
    <span class="c1"># Phylo.write(slink_unit, f&quot;simiiformes/rstar/multi_{root_name}.txt&quot;, format=&quot;newick&quot;)</span>
    <span class="k">return</span> <span class="n">slink_unit</span>


<div class="viewcode-block" id="TreeList_with_support">
<a class="viewcode-back" href="../../Consensus.html#Consensus.TreeList_with_support">[docs]</a>
<span class="k">class</span> <span class="nc">TreeList_with_support</span><span class="p">(</span><span class="n">dendropy</span><span class="o">.</span><span class="n">TreeList</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Child class of dendropy.datamodel.treecollectionmodel.TreeList, with support for several consensus constructions and support values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># EXPECTS TreeList with the same leaves. </span>
    <span class="c1"># EXPECTS TreeList of unrooted trees</span>

    <span class="k">def</span> <span class="nf">_make_edge_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">edge_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">dict_keys</span> <span class="o">=</span> <span class="n">edge_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="c1"># no duplicate keys in one tree</span>
            <span class="k">for</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">encode_bipartitions</span><span class="p">():</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dict_keys</span><span class="p">:</span>
                    <span class="n">edge_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">edge_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">edge_dict</span>
    
    <span class="k">def</span> <span class="nf">_make_all_TBE_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">bipartitions</span> <span class="o">=</span> <span class="p">[</span><span class="n">dendropy</span><span class="o">.</span><span class="n">Bipartition</span><span class="p">(</span><span class="n">leafset_bitmask</span> <span class="o">=</span> <span class="n">item</span><span class="p">,</span> <span class="n">tree_leafset_bitmask</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n_taxa</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">compile_bipartition</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>
        <span class="n">tbe_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TBE</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">)</span>
        <span class="n">bipartition_ints</span> <span class="o">=</span> <span class="p">[</span><span class="n">bipar</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span> <span class="k">for</span> <span class="n">bipar</span> <span class="ow">in</span> <span class="n">bipartitions</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_TBE_dict</span> <span class="o">=</span>  <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">bipartition_ints</span><span class="p">,</span> <span class="n">tbe_list</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">edge_dict</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;edge_dict&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_TBE_dict</span> <span class="o">=</span>  <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;all_TBE_dict&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span>  <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">TreeList</span><span class="p">):</span>
            <span class="c1"># just reference it</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">trees_init</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tree_with_support</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="c1"># the given trees are Tree_with_support, so initialize it with this (not to lose additional info)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">trees_init</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="c1">#self.taxon_namespace = args[0][0].taxon_namespace</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">trees_init</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span> <span class="o">=</span> <span class="p">[</span><span class="n">Tree_with_support</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_dict</span> <span class="o">=</span> <span class="n">edge_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_trees</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_taxa</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">leaf_nodes</span><span class="p">())</span>
        <span class="c1"># self.bipartition_encodings_list = [tree.encode_bipartitions() for tree in self]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edge_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_edge_dict</span><span class="p">()</span>
    
<div class="viewcode-block" id="TreeList_with_support.get">
<a class="viewcode-back" href="../../Consensus.html#Consensus.TreeList_with_support.get">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _type_</span>
<span class="sd">            _description_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edge_dict</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;edge_dict&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">TreeList</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">edge_dict</span> <span class="o">=</span> <span class="n">edge_dict</span><span class="p">)</span></div>




<div class="viewcode-block" id="TreeList_with_support.bootstrap_support">
<a class="viewcode-back" href="../../Consensus.html#Consensus.TreeList_with_support.bootstrap_support">[docs]</a>
    <span class="k">def</span> <span class="nf">bootstrap_support</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bipartition</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute bootstrap support of a bipartition against self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bipartition : `dendropy.datamodel.treemodel.Bipartition`</span>
<span class="sd">            Bipartition to evaluate bootstrap support</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Bootstrap support.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># computes bootstrap support of an edge.</span>
        <span class="c1"># bipartition: Bipartition object</span>

        <span class="n">key</span> <span class="o">=</span> <span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trees</span>
        <span class="k">return</span> <span class="mi">0</span></div>

    
<div class="viewcode-block" id="TreeList_with_support.compute_all_TBE">
<a class="viewcode-back" href="../../Consensus.html#Consensus.TreeList_with_support.compute_all_TBE">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_all_TBE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute all TBE of all bipartitions present in the treelist against self and save it in self.all_TBE_dict.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that has integers representing bipartitions as keys and TBE support as values. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_all_TBE_dict</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_TBE_dict</span></div>

    
    <span class="k">def</span> <span class="nf">TBE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bipartitions</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute TBE support of bipartitions against self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bipartitions : Iterable of `dendropy.datamodel.treemodel.Bipartition`</span>
<span class="sd">        Bipartitions to evaluate TBE support.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of TBE support</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TBE</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
    
<div class="viewcode-block" id="TreeList_with_support.majority_consensus">
<a class="viewcode-back" href="../../Consensus.html#Consensus.TreeList_with_support.majority_consensus">[docs]</a>
    <span class="k">def</span> <span class="nf">majority_consensus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes majority rule consensus.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tree_with_support</span>
<span class="sd">            Majority rule consensus tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree_leafset_bitmask</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n_taxa</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># corresponds to &quot;1111......1&quot;</span>
        <span class="n">bipartitions</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">bipar_ints</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">bipar_bs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trees</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">bipartitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dendropy</span><span class="o">.</span><span class="n">Bipartition</span><span class="p">(</span><span class="n">bitmask</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">leafset_bitmask</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">tree_leafset_bitmask</span> <span class="o">=</span> <span class="n">tree_leafset_bitmask</span><span class="p">,</span> <span class="n">is_rooted</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                <span class="n">bipar_ints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">);</span> <span class="n">bipar_bs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trees</span><span class="p">)</span>
        <span class="n">majority_tree</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">Tree</span><span class="o">.</span><span class="n">from_bipartition_encoding</span><span class="p">(</span><span class="n">bipartitions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
        <span class="n">bootstrap_support</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">bipar_ints</span><span class="p">,</span> <span class="n">bipar_bs</span><span class="p">))</span>
        <span class="c1"># majority_tree.bootstrap_support = bootstrap_support</span>
        <span class="k">return</span> <span class="n">Tree_with_support</span><span class="p">(</span><span class="n">majority_tree</span><span class="p">,</span> <span class="n">bootstrap_support</span> <span class="o">=</span> <span class="n">bootstrap_support</span><span class="p">,</span> <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeList_with_support.MAP">
<a class="viewcode-back" href="../../Consensus.html#Consensus.TreeList_with_support.MAP">[docs]</a>
    <span class="k">def</span> <span class="nf">MAP</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the most appearing tree topology.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List</span>
<span class="sd">            List of the most appearing tree topologies (has length &gt; 1 when more than two topologies have the same maximum count).</span>
<span class="sd">        </span>
<span class="sd">        int</span>
<span class="sd">            The number of occurrences of MAP trees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># returns tree(s) with maximum number of appearances</span>
        <span class="n">dict_topologies</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tree_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">tree_idx</span><span class="p">]</span>
            <span class="n">bipar_set</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">node</span><span class="o">.</span><span class="n">bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">postorder_internal_node_iter</span><span class="p">(</span><span class="n">exclude_seed_node</span><span class="o">=</span><span class="kc">True</span><span class="p">)})</span>
            <span class="k">if</span> <span class="n">bipar_set</span> <span class="ow">in</span> <span class="n">dict_topologies</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">dict_topologies</span><span class="p">[</span><span class="n">bipar_set</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree_idx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dict_topologies</span><span class="p">[</span><span class="n">bipar_set</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree_idx</span><span class="p">]</span>
        <span class="n">len_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">dict_topologies</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">len_list</span><span class="p">)</span>
        <span class="n">max_len_topology_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">dict_topologies</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">==</span><span class="n">max_len</span><span class="p">]</span>
        <span class="n">repr_trees</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#print(max_len_topology_indices)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">max_len_topology_indices</span><span class="p">:</span>
            <span class="n">repr_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">len_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">postorder_internal_edge_iter</span><span class="p">(</span><span class="n">exclude_seed_edge</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">len_dict</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">_bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()]</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">length</span><span class="o">/</span><span class="n">max_len</span>
            <span class="k">for</span> <span class="n">treeind</span> <span class="ow">in</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">treeind</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">postorder_internal_edge_iter</span><span class="p">(</span><span class="n">exclude_seed_edge</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="n">len_dict</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">_bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()]</span> <span class="o">+=</span> <span class="n">edge</span><span class="o">.</span><span class="n">length</span><span class="o">/</span><span class="n">max_len</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">repr_tree</span><span class="o">.</span><span class="n">postorder_internal_edge_iter</span><span class="p">(</span><span class="n">exclude_seed_edge</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">len_dict</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">_bipartition</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()]</span>
            <span class="n">repr_trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">repr_tree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">repr_trees</span><span class="p">,</span> <span class="n">max_len</span></div>

        

    
<div class="viewcode-block" id="TreeList_with_support.greedy_TBE_consensus">
<a class="viewcode-back" href="../../Consensus.html#Consensus.TreeList_with_support.greedy_TBE_consensus">[docs]</a>
    <span class="k">def</span> <span class="nf">greedy_TBE_consensus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalization</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Greedily (in terms of TBE or its unnormalized version) add edges to construct consensus tree.</span>
<span class="sd">        </span>
<span class="sd">        The candidate bipartitions are the set of all bipartitions included in self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        normalization : bool, optional</span>
<span class="sd">            Whether to use the usual TBE or unnormalized TBE.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tree_with_support</span>
<span class="sd">            Consensus tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">all_bipartitions</span> <span class="o">=</span> <span class="p">[</span><span class="n">dendropy</span><span class="o">.</span><span class="n">Bipartition</span><span class="p">(</span><span class="n">leafset_bitmask</span> <span class="o">=</span> <span class="n">item</span><span class="p">,</span> <span class="n">tree_leafset_bitmask</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">n_taxa</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">all_edges</span><span class="p">]</span>
        <span class="n">all_Bits</span> <span class="o">=</span> <span class="p">[</span><span class="n">Bits</span><span class="p">(</span><span class="n">uint</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">(),</span> <span class="n">length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_taxa</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">all_bipartitions</span><span class="p">]</span>
        <span class="c1"># compile all bipartitions</span>
        <span class="k">for</span> <span class="n">bipartition</span> <span class="ow">in</span> <span class="n">all_bipartitions</span><span class="p">:</span>
            <span class="n">bipartition</span><span class="o">.</span><span class="n">compile_leafset_bitmask</span><span class="p">()</span>
        
        <span class="n">encoding_bipartitions</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">encoding_TS</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">normalization</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_TBE_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tbe_list</span><span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">TBE</span><span class="p">(</span><span class="n">all_bipartitions</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tbe_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_TBE_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">sort_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">tbe_list</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># high to low</span>
            <span class="n">all_Bits_sorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_Bits</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sort_index</span><span class="p">]</span>
            <span class="n">all_bipartitions_sorted</span> <span class="o">=</span>  <span class="p">[</span><span class="n">all_bipartitions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sort_index</span><span class="p">]</span>
            <span class="n">tbe_list_sorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">tbe_list</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sort_index</span><span class="p">]</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_Bits_sorted</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bipar_bits</span> <span class="o">=</span> <span class="n">all_Bits_sorted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">TS</span> <span class="o">=</span> <span class="n">tbe_list_sorted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">bipartition</span> <span class="o">=</span> <span class="n">all_bipartitions_sorted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">encoding_TS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TS</span><span class="p">)</span>
                <span class="n">encoding_bipartitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bipartition</span><span class="p">)</span>
                <span class="c1"># delete incompatible edges</span>
                <span class="k">if</span> <span class="n">TS</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">count_1</span> <span class="o">=</span> <span class="n">bipar_bits</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">count_1</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">count_1</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_taxa</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">continue</span> <span class="c1"># compatible with all edges</span>
                
                <span class="n">remain_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_Bits_sorted</span><span class="p">))</span> <span class="k">if</span> <span class="n">_compatible</span><span class="p">(</span><span class="n">all_Bits_sorted</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bipar_bits</span><span class="p">)</span> <span class="p">]</span>
                <span class="n">all_Bits_sorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_Bits_sorted</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">remain_index</span><span class="p">]</span>
                <span class="n">all_bipartitions_sorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_bipartitions_sorted</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">remain_index</span><span class="p">]</span>
                <span class="n">tbe_list_sorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">tbe_list_sorted</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">remain_index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_TBE_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tbe_list</span><span class="o">=</span> <span class="n">unnormalized_TBE</span><span class="p">(</span><span class="n">all_bipartitions</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">normalized_tbe_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_TBE_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">normalized_tbe_list</span>
                <span class="n">refinfos</span> <span class="o">=</span> <span class="n">_create_refinfo</span><span class="p">(</span><span class="n">all_bipartitions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_taxa</span><span class="p">)</span>
                <span class="n">normalizing_constants</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">refinfos</span><span class="p">[</span><span class="n">bipar_int</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">bipar_int</span> <span class="ow">in</span> <span class="n">all_edges</span><span class="p">])</span>
                <span class="n">tbe_list</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">*</span> <span class="n">normalizing_constants</span>

            <span class="n">sort_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">tbe_list</span><span class="p">)</span> <span class="c1"># low to high</span>
            <span class="n">all_Bits_sorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_Bits</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sort_index</span><span class="p">]</span>
            <span class="n">all_bipartitions_sorted</span> <span class="o">=</span>  <span class="p">[</span><span class="n">all_bipartitions</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sort_index</span><span class="p">]</span>
            <span class="n">tbe_list_sorted</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tbe_list</span><span class="p">[</span><span class="n">sort_index</span><span class="p">])</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_Bits_sorted</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bipar_bits</span> <span class="o">=</span> <span class="n">all_Bits_sorted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">TS</span> <span class="o">=</span> <span class="n">tbe_list_sorted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">bipartition</span> <span class="o">=</span> <span class="n">all_bipartitions_sorted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">encoding_TS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">TS</span><span class="p">)</span>
                <span class="n">encoding_bipartitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bipartition</span><span class="p">)</span>

                <span class="c1"># delete incompatible edges</span>
                <span class="k">if</span> <span class="n">TS</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">count_1</span> <span class="o">=</span> <span class="n">bipar_bits</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">count_1</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">count_1</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_taxa</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">continue</span> <span class="c1"># compatible with all edges</span>
                <span class="n">remain_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_Bits_sorted</span><span class="p">))</span> <span class="k">if</span> <span class="n">_compatible</span><span class="p">(</span><span class="n">all_Bits_sorted</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bipar_bits</span><span class="p">)</span> <span class="p">]</span>
                <span class="n">all_Bits_sorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_Bits_sorted</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">remain_index</span><span class="p">]</span>
                <span class="n">all_bipartitions_sorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_bipartitions_sorted</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">remain_index</span><span class="p">]</span>
                <span class="n">tbe_list_sorted</span> <span class="o">=</span> <span class="p">[</span><span class="n">tbe_list_sorted</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">remain_index</span><span class="p">]</span>
        
        <span class="n">encoding_bipartition_ints</span> <span class="o">=</span> <span class="p">[</span><span class="n">bipar</span><span class="o">.</span><span class="n">split_as_int</span><span class="p">()</span> <span class="k">for</span> <span class="n">bipar</span> <span class="ow">in</span> <span class="n">encoding_bipartitions</span><span class="p">]</span>
        <span class="n">greedy_tree</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">Tree</span><span class="o">.</span><span class="n">from_bipartition_encoding</span><span class="p">(</span><span class="n">encoding_bipartitions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normalization</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Tree_with_support</span><span class="p">(</span><span class="n">greedy_tree</span><span class="p">,</span> <span class="n">TBE_support</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span> <span class="n">encoding_bipartition_ints</span><span class="p">,</span> <span class="n">encoding_TS</span> <span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Tree_with_support</span><span class="p">(</span><span class="n">greedy_tree</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeList_with_support.Rstar_consensus">
<a class="viewcode-back" href="../../Consensus.html#Consensus.TreeList_with_support.Rstar_consensus">[docs]</a>
    <span class="k">def</span> <span class="nf">Rstar_consensus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_index</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">root_name</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute R* consensus.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        root_index : int, optional</span>
<span class="sd">            The index of root in self.taxon_namespace, by default None.</span>
<span class="sd">            You need to specify either ``root_index`` or ``root_name``.</span>
<span class="sd">        root_name : _type_, optional</span>
<span class="sd">            The name of root taxa, by default None</span>
<span class="sd">            You need to specify either ``root_index`` or ``root_name``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tree_with_support</span>
<span class="sd">            R* consensus tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># specify either root_index or root_name</span>
        <span class="c1"># currently very inefficient and messy</span>

        <span class="k">if</span> <span class="n">root_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">root_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Error: Both root_index and root_name are specified. Specify only one of them.&quot;</span><span class="p">)</span>
            <span class="n">root_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">[</span><span class="n">root_index</span><span class="p">]</span><span class="o">.</span><span class="n">label</span>
        <span class="k">elif</span> <span class="n">root_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Error: You need to specify either root_index or root_name.&quot;</span><span class="p">)</span>
        
        <span class="n">taxon_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">]</span> <span class="p">)</span> <span class="o">==</span> <span class="n">root_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">taxon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">taxon_idx</span><span class="p">)]</span>

        <span class="n">trees</span> <span class="o">=</span> <span class="p">[</span><span class="n">Phylo</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">file</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">as_string</span><span class="p">(</span><span class="n">schema</span><span class="o">=</span><span class="s2">&quot;newick&quot;</span><span class="p">))</span> <span class="p">,</span> <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;newick&quot;</span> <span class="p">)</span> <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        
        <span class="n">tree</span> <span class="o">=</span> <span class="n">Tree_with_support</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">data</span> <span class="o">=</span> <span class="n">_Rstar</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">root_name</span><span class="p">)</span><span class="o">.</span><span class="fm">__format__</span><span class="p">(</span><span class="s2">&quot;newick&quot;</span><span class="p">),</span> <span class="n">schema</span><span class="o">=</span><span class="s2">&quot;newick&quot;</span><span class="p">,</span> <span class="n">taxon_namespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taxon_namespace</span><span class="p">,</span> <span class="n">rooting</span><span class="o">=</span><span class="s2">&quot;force-rooted&quot;</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">dendropy</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">taxon</span> <span class="o">=</span> <span class="n">taxon</span><span class="p">,</span> <span class="n">edge_length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">seed_node</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">is_rooted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">tree</span></div>
</div>

    

    <span class="c1"># def Qstar_consensus(self):</span>
    <span class="c1">#     dict_Q_count = count_quartets2(self)</span>
    <span class="c1">#     list_Qmaj = construct_Qmaj(dict_Q_count, self.taxon_namespace)</span>
    <span class="c1">#     write_Qmaj_quartfile(list_Qmaj, self.taxon_namespace)</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         subprocess.run(&quot;./qstar&quot;)</span>
    <span class="c1">#     except:</span>
    <span class="c1">#         sys.exit(&quot;Error: Error running ./qstar. Make sure that qstar executable is in the same directory.&quot;)</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         subprocess.run(&quot;./tree-pop&quot;)</span>
    <span class="c1">#     except:</span>
    <span class="c1">#         sys.exit(&quot;Error: Error running ./tree-pop. Make sure that qstar executable is in the same directory.&quot;)</span>
    <span class="c1">#     qstar_tree = Tree_with_support.get(path = &quot;treefile&quot;, schema=&quot;newick&quot;, taxon_namespace = self.taxon_namespace)</span>
    <span class="c1">#     return qstar_tree</span>
    
    <span class="c1"># def Qstar_by_Rstar(self):</span>
    <span class="c1">#     # construct rstar consensus by picking first taxon as root.</span>
    <span class="c1">#     root_name = self.taxon_namespace[0].label</span>
    <span class="c1">#     taxon_idx = np.where(np.array( [item.label for item in self.taxon_namespace] ) == root_name)[0][0] # which should equal zero</span>
    <span class="c1">#     taxon = self.taxon_namespace[int(taxon_idx)]</span>

    <span class="c1">#     trees = [Phylo.read(file = StringIO(tree.as_string(schema=&quot;newick&quot;)) , format = &quot;newick&quot; ) for tree in self]</span>
        
    <span class="c1">#     tree = Tree_with_support.get(data = _Rstar(trees, root_name).__format__(&quot;newick&quot;), schema=&quot;newick&quot;, taxon_namespace = self.taxon_namespace, rooting=&quot;force-rooted&quot;)</span>
    <span class="c1">#     node = dendropy.Node(taxon = taxon, edge_length = 1)</span>
    <span class="c1">#     tree.seed_node.add_child(node)</span>
    <span class="c1">#     print(len(tree.leaf_nodes()))</span>
    <span class="c1">#     tree.is_rooted = False</span>
    <span class="c1">#     tree.encode_bipartitions()</span>

    <span class="c1">#     # now construct majority consensus</span>
    <span class="c1">#     maj_tree = self.majority_consensus()</span>
    <span class="c1">#     maj_tree.encode_bipartitions()</span>

    <span class="c1">#     # store legit bipartitions</span>
    <span class="c1">#     ## first, mark legitimate edges with 1, unknown edges with -1</span>
    <span class="c1">#     bipartitions = []</span>
    <span class="c1">#     maj_bipar_ints = [edge.bipar.split_as_int() for edge in maj_tree.postorder_edge_iter()]</span>
    <span class="c1">#     for edge in tree.postorder_edge_iter():</span>
    <span class="c1">#         if edge.is_leaf():</span>
    <span class="c1">#             edge.annotations.add_new(name=&quot;in&quot;, value=1)</span>
    <span class="c1">#             bipartitions.append(edge.bipartition)</span>
    <span class="c1">#         elif edge.bipartition.split_as_int() in maj_bipar_ints:</span>
    <span class="c1">#             edge.annotations.add_new(name=&quot;in&quot;, value=1)</span>
    <span class="c1">#             bipartitions.append(edge.bipartition)</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             edge.annotations.add_new(name=&quot;in&quot;, value=-1)</span>
        
    <span class="c1">#     ## Check if the unknown edges are legitimate</span>
    <span class="c1">#     for edge in tree.postorder_edge_iter():</span>
    <span class="c1">#         if edge.annotations[&#39;in&#39;].value == 1:</span>
    <span class="c1">#             continue</span>
    <span class="c1">#         elif edge.annotations[&#39;in&#39;].value == -1:</span>
    <span class="c1">#             # unknown, check if it&#39;s valid</span>
    <span class="c1">#             head = edge.head_node</span>
    <span class="c1">#             tail = edge.tail_node</span>
    <span class="c1">#             tree.reroot_at_node(tail)</span>
    <span class="c1">#             head_adjacents = head.child_nodes()</span>
    <span class="c1">#             tail_adjacents = tail.child_nodes() # this still includes head</span>
    <span class="c1">#             tail_adjacents = set(tail_adjacents) - {head}</span>
    <span class="c1">#             for s_a, s_b in itertools.combinations(head_adjacents, 2):</span>
    <span class="c1">#                 for s_c, s_d in itertools.combinations(tail_adjacents, 2):</span>
    <span class="c1">#                     for a in s_a.leaf_nodes():</span>
    <span class="c1">#                         for b in s_b.leaf_nodes():</span>
    <span class="c1">#                             for c in s_c.leaf_nodes():</span>
    <span class="c1">#                                 for d in s_d.leaf_nodes():</span>
    <span class="c1">#                                     pass</span>
                                        

    <span class="c1"># def Qstar_mode_consensus(self):</span>
    <span class="c1">#     dict_Q_count = count_quartets2(self)</span>
    <span class="c1">#     list_Qmaj = construct_Qmaj(dict_Q_count, self.taxon_namespace)</span>
    <span class="c1">#     write_Qmaj_quartfile(list_Qmaj, self.taxon_namespace)</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         subprocess.run(&quot;./qstar&quot;)</span>
    <span class="c1">#     except:</span>
    <span class="c1">#         sys.exit(&quot;Error: Error running ./qstar. Make sure that qstar executable is in the same directory.&quot;)</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         subprocess.run(&quot;./tree-pop&quot;)</span>
    <span class="c1">#     except:</span>
    <span class="c1">#         sys.exit(&quot;Error: Error running ./tree-pop. Make sure that qstar executable is in the same directory.&quot;)</span>
    <span class="c1">#     qstar_tree = Tree_with_support.get(path = &quot;treefile&quot;, schema=&quot;newick&quot;)</span>
    <span class="c1">#     return qstar_tree</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Yuki Takazawa.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>